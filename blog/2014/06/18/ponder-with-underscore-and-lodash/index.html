
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>由Underscore与Lodash的差异引发的思考 - Silent Reverie</title>
  <meta name="author" content="俞乐">

  
  <meta name="description" content="Emil6us's Space">
  
  <meta name="keywords" content="supli, emiblus, myunlessor, photoshop, javascript, html5, css3">

  
  <meta name="description" content="自打接触Underscore以来就对其爱不释手，尔后又了解到Lodash。这两个类库为我们提供了一系列相当不错的跟函数式编程相关的方法。Underscore以API实现简洁著称。Lodash作为Underscore的后继者，除了对Underscore现有API功能使用上进行扩充外， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://myunlessor.me/blog/2014/06/18/ponder-with-underscore-and-lodash">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Silent Reverie" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script type="text/javascript" src="/javascripts/link_open_in_blank.js"></script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-41039292-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Silent Reverie</a></h1>
  
    <h2>Creating memories with the awesome stuff I've learnt.</h2>
  
</hgroup>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:myunlessor.me" />
    <input class="search" type="text" name="q" results="0" placeholder="搜索"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/about.html">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">由Underscore与Lodash的差异引发的思考</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T22:24:00+08:00" pubdate data-updated="true">2014年06月18日</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>自打接触<a href="http://underscorejs.org/">Underscore</a>以来就对其爱不释手，尔后又了解到<a href="http://lodash.com/">Lodash</a>。这两个类库为我们提供了一系列相当不错的跟函数式编程相关的方法。Underscore以API实现简洁著称。Lodash作为Underscore的后继者，除了对Underscore现有API功能使用上进行扩充外，更是添加了不少令人难忘的API，在性能上也更为出彩，而且还能根据需要构建自己的子集方法。相较而言，我更亲睐于Lodash，而且成了日常项目开发的标配。</p>

<p>目前Lodash的最新版本是v2.4.1，功能上可以说完全是Underscore的超集。只要Underscore添加了啥新功能时，Lodash都会及时覆盖更新，以维护它一如既往超集的地位。然而，当Underscore更新到v1.6.0时，这个版本添加了一个很棒的功能，其为方法<code>_.partial</code>添加了占位符参数的支持（如果没猜错的话，这个特性应该是从<a href="http://osteele.com/sources/javascript/functional/">functional.js</a>中移植过来了）。自然地，希望Lodash也能很快地对<code>_.partial</code>做增强处理。可是，四个月过去了，Lodash似乎处于冬眠状态，一点都不见有动静。于是乎，到目前为止，Lodash的功能不足以完全覆盖Underscore了，于是也就有了这篇文章。</p>

<!-- more -->


<h2>循序渐进</h2>

<p>还是以例子引入话题，假如我要将数组<code>['4', '8', '15', '16', '23', '42']</code>(<a href="http://www.douban.com/group/topic/6251101/">神奇数字</a>)中所有字符串元素变换为数字型。不假思索后，我们会这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [4, 8, 15, 16, 23, 42]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="s1">&#39;16&#39;</span><span class="p">,</span> <span class="s1">&#39;23&#39;</span><span class="p">,</span> <span class="s1">&#39;42&#39;</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>没错，这没什么问题。稍微观察一下，我们会发现，传递给<code>_.map</code>方法的匿名回调方法仅仅做了件简单的事，将其第一个参数传进<code>Number</code>函数中调用后直接返回。这种做法其实就相当于：你实际要执行的是<code>f</code>函数，而你却通过调用<code>g</code>函数间接执行<code>f</code>函数，而事实上你完全可以直接执行<code>f</code>函数的，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">val</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; true</span>
</span><span class='line'><span class="nx">f</span><span class="p">(</span><span class="s1">&#39;stupid&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="nx">g</span><span class="p">(</span><span class="s1">&#39;stupid&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，上述数组变换实际可以简化为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [4, 8, 15, 16, 23, 42]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="s1">&#39;16&#39;</span><span class="p">,</span> <span class="s1">&#39;23&#39;</span><span class="p">,</span> <span class="s1">&#39;42&#39;</span><span class="p">],</span> <span class="nb">Number</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>嗯，确实是这么回事^-^。</p>

<p>再比如，我想将数组<code>['1NO', '2FOOL', '3ME']</code>中所有字符串元素解析为数字型。我们知道将字符串解析为数字型可以通过<code>parseInt</code>直接得到，像这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;1NO&#39;</span><span class="p">);</span>     <span class="c1">//=&gt; 1</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">middle</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;2FOOL&#39;</span><span class="p">);</span>  <span class="c1">//=&gt; 2</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">last</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;3ME&#39;</span><span class="p">);</span>      <span class="c1">//=&gt; 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>It works! 于是以迅雷不及掩耳的速度得出结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [1, 2, 3]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;3ME&#39;</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>Perfect！细看一下，咿，这不是和之前那个例子一样的嘛，这次学聪明了，窃喜之下后马上将结果改为如下，也没忘夸奖下自己随机应变的能力：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [1, NaN, NaN]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;3ME&#39;</span><span class="p">],</span> <span class="nb">parseInt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>等等，我勒个去，结果不符合预期了，这是怎么回事？！</p>

<p>脑袋稍微转下，原来是这么回事，当你把<code>parseInt</code>直接作为<code>_.map</code>方法的回调时，<code>parseInt</code>执行的时候实际是传入了三个参数(元素值，元素索引，数组本身)。
所以上述代码实际等价于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">ary</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;3ME&#39;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [1, NaN, NaN]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">ary</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">idx</span><span class="p">,</span> <span class="nx">ary</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">idx</span><span class="p">,</span> <span class="nx">ary</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ary</span><span class="p">);</span>     <span class="c1">//=&gt; 1</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">middle</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">ary</span><span class="p">);</span>  <span class="c1">//=&gt; NaN</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">last</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="s1">&#39;3ME&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">ary</span><span class="p">);</span>      <span class="c1">//=&gt; NaN</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>parseInt</code>调用时可接收可选的第二个参数，元素索引值作为第二个参数无形中传入到<code>parseInt</code>，呜呼哀哉！第一个例子为什么没问题？因为Number只接收一个参数，而把其后的所有参数都忽略，所以安然无恙。这么看来<code>Explicit is better than implicit(显优于隐)</code>的确是真理啊！</p>

<p>在此，我不想弹劾<code>parseInt</code>直接作为<code>_.map</code>回调使用的情况，我只想吐嘈下<code>parseInt</code>不显式指定第二个参数调用的隐患。MDN上关于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt API</a>的定义是强调指明要传入<code>radix(基数)</code>值作为解析数字的依据的。</p>

<p>除此以外，我想强调的是<code>Number</code>和<code>parseInt</code>是否有<code>共同特征(pattern recognition)</code>值得我们去挖掘的呢？答案是有的。<code>_.map</code>遍历数组元素时，其都是将数组元素传入到<code>Number</code>或<code>parseInt</code>作为其第一个参数进行执行的。而这是函数式编程很重要的一个特点，对函数进行<code>柯里化(curry)</code>或<code>偏应用(partial)</code>处理时，传给函数的第一个参数往往是数据流，<code>数据流(data flow)</code>也是函数式编程不同于<code>控制流(control flow)</code>的非函数式编程的一个显著区别。</p>

<p>回到之前的问题，既然<code>parseInt</code>不能直接作为<code>_.map</code>回调处理，而我又不想使用匿名函数间接调用<code>parseInt</code>的刻板方法，那么还有其他办法吗？答案是有的。</p>

<p>试想，我们遇到的问题是<code>parseInt</code>作为<code>_.map</code>回调执行时，无形中其第二个参数被污染了。反过来想，我们要找到一个办法使得其第二个参数免受污染。所幸的是，Underscore v1.6.0版本中提供的<code>_.partial</code>正好能满足这一需求。</p>

<p>我的想法是，利用<code>_.partial</code>对<code>parseInt</code>进行偏应用处理，返回得到的新函数再作为回调传入<code>_.map</code>中，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [1, 2, 3]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;3ME&#39;</span><span class="p">],</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，我们为<code>parseInt</code>预填充了两个参数：第一个参数传入<code>_</code>代表参数占位符，它是动态值；第二个传入基数值10，它是不变的，这样我们就将其第第二个参数“锁定”了。当<code>_.map</code>回调函数被执行时，它还是依次接收三个参数回来，只不过这次接收的第一个参数（数组元素作为数据填补）代替了参数占位符的位置，第二、三个参数被依次追加到<code>parseInt</code>末尾而被忽略，于是我们的代码正常工作了。</p>

<p>然而，这行代码Underscore v1.6.0+版本中才有效，对于Lodash或更低版本的Underscore，我们该怎么办呢？这时函数柯里化的威力就体现出来了。因为<code>parseInt</code>接收两个参数，于是我构建如下的二级柯里化函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">curry2</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">second</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">fun</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">);</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数<code>curry2</code>调用时接收一个希望被柯里化的函数作为参数传入，方法体中返回一个匿名函数，接收单一参数，而在匿名函数中又再次返回一个匿名函数，同样接收单一参数，直到柯里化函数执行两次时，被柯里化的函数得以执行，两级柯里化参数逆序传入而返回。</p>

<p>应用到这个例子，即：我们对<code>parseInt</code>进行柯里化处理，执行一次传入参数10，也是预填充第二个参数，结果返回新的函数等待<code>_.map</code>被执行时将第一个参数传递进行而返回结果值，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [1, 2, 3]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;3ME&#39;</span><span class="p">],</span> <span class="nx">curry2</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">)(</span><span class="mi">10</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个妥协的解决方法里，我们借助了自己构建的柯里化函数作为辅助。这不禁让我这么想：难道在这泱泱几十号工具方法中，在这个问题上一无是处，无一能为我所用，反倒要依赖外援？思考片刻后，依照<code>curry2</code>的思路，想到Lodash不是提供有<code>_.partialRight</code>方法嘛！从左往右填充参数不行，那就从右往左介入。就像<code>curry2</code>那样给<code>parseInt</code>预填充第二个参数，然后等待<code>_.map</code>填充第一个参数后执行，于是写了如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [1, NaN, NaN]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;3ME&#39;</span><span class="p">],</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partialRight</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果不尽如人意，和<code>parseInt</code>直接作为<code>_.map</code>回调函数传入时结果没什么两样，执行时<code>parseInt</code>仍是被<code>_.map</code>传回来的多余参数污染了，基数10成为了<code>parseInt</code>的末尾参数而直接忽略了。多余？这给我提了个醒，如果我能将<code>_.map</code>传回来的多余的后两参数过滤掉，那么<code>parseInt</code>被执行时作为基数10的末尾参数是不是就是作为其第二个参数传入而正常了。Great！现在的问题变成了如何将<code>_.map</code>传回来的多余的后两参数过滤掉？思考良久后我辗转想到了<code>_.identity</code>。<code>_.identity</code>应该算Lodash中倒数第二简单的方法了吧，最简单的是<code>_.noop</code>，它们各自定义如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">noop</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">identity</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">val</span><span class="p">;</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单的东西并非一无是处。麻雀虽小，五脏俱全。有时候往往是简单的东西才是我们需要的东西。咋一看，<code>_.identity</code>不就是你给它什么输入，它就给你返回什么嘛。可是当你换个角度想，你却发现了别样的东西，直接上代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">identity</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">);</span>                  <span class="c1">//=&gt; &#39;I&#39;</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">identity</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;FOOL&#39;</span><span class="p">);</span>          <span class="c1">//=&gt; &#39;I&#39;</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">identity</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;YOU&#39;</span><span class="p">);</span>   <span class="c1">//=&gt; &#39;I&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>发现了什么？所以，更准确地说，无论你给<code>_.identity</code>传入多少个参数，结果都是返回给你传入的第一个参数。这样一想，我传三个参数给它，结果它只把第一个参数返回了，剩余那两个参数呢？消失在茫茫人海之中，不见了。Good Job！</p>

<p>好了，现在解决了参数过滤的问题，我该怎么把过滤后存活下来的第一个参数传给<code>partial right</code>后的<code>parseInt</code>函数使用呢。我们需要管道进行衔接，一个函数的输出作为接下来另一个函数的输入，<code>_.compose</code>不正是专门做这事的嘛，Yeah！</p>

<p>假设<code>f</code>和<code>g</code>是两函数，<code>f</code>函数调用后的输出作为<code>g</code>函数的输入，其中<code>x</code>是<code>f</code>的输入值，则以下等式是成立的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; true</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">isEqual</span><span class="p">(</span> <span class="nx">g</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)),</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">f</span><span class="p">)(</span><span class="nx">x</span><span class="p">)</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了以上的分析后，我们通过<code>_.compose</code>作为纽带将<code>partial right</code>后的<code>parseInt</code>和<code>_.identity</code>衔接起来，最终得到答案：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [1, 2, 3]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;1NO&#39;</span><span class="p">,</span> <span class="s1">&#39;2FOOL&#39;</span><span class="p">,</span> <span class="s1">&#39;3ME&#39;</span><span class="p">],</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partialRight</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="nx">_</span><span class="p">.</span><span class="nx">identity</span> <span class="p">)</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到以上这行代码，你在脑海中涌动的应该就是数据在各个函数间依次流动着而最终得到结果，即函数式编程的<code>数据流(data flow)</code>思想。我并不是倡导在实际工作中要写这种代码，更多的是体会函数式编程的思维，那种自成一体的曼妙。函数式编程的思想表现的不是<code>MARVEL</code>旗下的那些个个人英雄主义气概，而是各个功能单一的函数组合在一起才能体现的威力。</p>

<h2>思维发散</h2>

<p>另一个例子：将数组<code>['left  ', ' center ', '  right']</code>中各个字符串元素两边的空白符去除，长驱直入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [&#39;left&#39;, &#39;center&#39;, &#39;right&#39;]</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">([</span><span class="s1">&#39;left  &#39;</span><span class="p">,</span> <span class="s1">&#39; center &#39;</span><span class="p">,</span> <span class="s1">&#39;  right&#39;</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">trim</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>仔细看这段代码，你会看到另一种模式，匿名函数里返回的是第一个参数调用某个方法的结果。函数式编程的核心是函数，而不是方法。我们要将方法调用转化为函数调用，才更能体现函数式风格。Underscore和Lodash都提供了<code>_.result</code>方法。通过这个方法我们可以将方法调用转化为函数调用，也即：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39; center &#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; true</span>
</span><span class='line'><span class="nx">str</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span> <span class="o">===</span> <span class="nx">_</span><span class="p">.</span><span class="nx">result</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s1">&#39;trim&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>_.result</code>调用像不像此前的<code>parseInt</code>？这样，我们之前的方法再次奏效：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">ary</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;left  &#39;</span><span class="p">,</span> <span class="s1">&#39; center &#39;</span><span class="p">,</span> <span class="s1">&#39;  right&#39;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Underscore v1.6.0</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">ary</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">result</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="s1">&#39;trim&#39;</span> <span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Lodash v2.4.1</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">ary</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partialRight</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">result</span><span class="p">,</span> <span class="s1">&#39;trim&#39;</span> <span class="p">),</span> <span class="nx">_</span><span class="p">.</span><span class="nx">identity</span> <span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Underscore &amp; Lodash</span>
</span><span class='line'><span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">ary</span><span class="p">,</span> <span class="nx">curry2</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">result</span> <span class="p">)(</span> <span class="s1">&#39;trim&#39;</span> <span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>延伸拓展</h2>

<p>前面提到了<code>_.identity</code>方法，如果换种角度来看，可以把它当作参数过滤器使用。可是它是有局限性的，它只能过滤第一个参数。假如某种情况下我要过滤出输入参数的前两个参数，这回该怎么办？我们知道函数只能返回一个值，要返回多个值的话，则可以将多个值以数组形式返回。以下是过滤前两个参数的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">take2</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [&#39;first&#39;, &#39;second&#39;]</span>
</span><span class='line'><span class="nx">take2</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="s1">&#39;thrid&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [&#39;first&#39;, &#39;second&#39;]</span>
</span><span class='line'><span class="nx">take2</span><span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="s1">&#39;thrid&#39;</span><span class="p">,</span> <span class="s1">&#39;forth&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>解决了过滤两个参数的问题，可是它有个瑕疵，它的输出是以数组形式返回的。如果这种输出直接作为另一个函数的输入，这将无法衔接起来，因为我们的接收方函数要求参数是单个单个传入，而不是给它灌入单个数组。于是，我们接下来需要某种能够将数组变换为单个单个参数传入接收方函数的方法。</p>

<p>先看以下举例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">max</span><span class="p">(</span><span class="cm">/* args */</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; 42</span>
</span><span class='line'><span class="nx">max</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>max</code>方法很简单，它返回任意输入Number型参数的最大值。给它输入的单个单个参数依次是<code>8, 4, 15, 42, 23, 16</code>。现在假设我只想知道输入参数的前两个哪个最大。我们脑海里首先闪过的可能是如下答案：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">max_initial</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">max</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; 8</span>
</span><span class='line'><span class="nx">max_initial</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来还不错！但我们前面定义了专门充当“参数过滤器”的函数<code>take2</code>，让我们试图将它介入其中，像如下那样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">max_initial2</span><span class="p">(</span><span class="cm">/* args */</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">take2</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; 8</span>
</span><span class='line'><span class="nx">max_initial2</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>感谢<code>Function.prototype.apply</code>方法，我们成功地将参数过滤了，并传给了<code>max</code>，It Works！可是盯着它看下，怎么看怎么不舒服。再改进下吧～前面我们提到<code>_.compose</code>方法可以将参数输入输出串联起来，那再试图让<code>_.compose</code>介入进来吧！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">max_initial3</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">max</span><span class="p">,</span> <span class="nx">take2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; NaN</span>
</span><span class='line'><span class="nx">max_initial3</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Does it work？Nope！Why？<code>max_initial3</code>函数执行实际等价于如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">//=&gt; [8, 4]</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">take2</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; NaN</span>
</span><span class='line'><span class="nx">max</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将<code>take2</code>执行后返回的数组值直接传递给了<code>max</code>，而<code>max</code>需接收的是单个单个的参数。由于接口的不一致，我们的尝试失败了。既然接口不一致，我们何不制造个<code>适配器(Adapter)</code>以适配接口呢！我们需要什么样的适配器？我们需要将数组参数转化为单个单个参数的适配器——我们需要<code>splat</code>适配器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">splat</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">fun</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">array</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">maxAdapted</span> <span class="o">=</span> <span class="nx">splat</span><span class="p">(</span><span class="nx">max</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; 8</span>
</span><span class='line'><span class="nx">maxAdapted</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Looks pretty neat, doesn&rsquo;t it?有了适配器后，我们再用<code>_.compose</code>将它们衔接起来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">max_initial4</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">splat</span><span class="p">(</span><span class="nx">max</span><span class="p">),</span> <span class="nx">take2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; 8</span>
</span><span class='line'><span class="nx">max_initial4</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>瞧，它又正常工作了，多亏了<code>splat</code>适配器。适配器用于适配不同的接口，以此将不同的接口衔接起来，它的职责是单一的，因此也可以复用。</p>

<p>现在我们有了将数组参数转化为单个单个参数的<code>splat</code>适配器。反过来，我们何不再制造个将单个单个参数转化为数组参数的适配器呢？我们估且叫它<code>unsplat</code>吧！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">unsplat</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">fun</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">));</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 既然我们使用Underscore或Lodash，我们何不写成这样呢！</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">unsplat</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">fun</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">toArray</span><span class="p">(</span><span class="nx">arguments</span><span class="p">));</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>unsplat</code>能用在什么地方呢？Let&rsquo;s have a try!</p>

<p>前面我们定义有<code>take2</code>，我们何不定义个更一般的<code>take</code>函数呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">take</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [8, 4]</span>
</span><span class='line'><span class="nx">take</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了更一般的<code>take</code>函数，我们就可以基于它生成过滤任意多个前置参数的“参数过滤器”函数了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">take2</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span><span class="nx">take</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">take3</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span><span class="nx">take</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [8, 4]</span>
</span><span class='line'><span class="nx">take2</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [8, 4, 15]</span>
</span><span class='line'><span class="nx">take3</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这不对！之前我们调用<code>take2</code>的时候传递给它的是单个单个的参数，可是这回调用时传递的却是数组参数。不行，我们需要适配器，我们需要将单个单个参数转化为数组参数的适配器——我们需要<code>unsplat</code>适配器！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">take2</span> <span class="o">=</span> <span class="nx">unsplat</span><span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span><span class="nx">take</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">take3</span> <span class="o">=</span> <span class="nx">unsplat</span><span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span><span class="nx">take</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [8, 4]</span>
</span><span class='line'><span class="nx">take2</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; [8, 4, 15]</span>
</span><span class='line'><span class="nx">take3</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这回正常了！回到最初的问题，针对<code>max</code>函数，给它输入的单个单个参数依次是<code>8, 4, 15, 42, 23, 16</code>。现在假设我只想知道输入参数的前三个哪个最大，我们有了一般的答案：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">max_revamped</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span> <span class="nx">splat</span><span class="p">(</span><span class="nx">max</span><span class="p">),</span> <span class="nx">unsplat</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span><span class="nx">take</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; 15</span>
</span><span class='line'><span class="nx">max_revamped</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now everything is under control! 如果我们了解<code>_.wrap</code>方法，我们可以做的更疯狂：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">max_fancy</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span>
</span><span class='line'>  <span class="nx">_</span><span class="p">.</span><span class="nx">wrap</span><span class="p">(</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">splat</span> <span class="p">)(),</span>
</span><span class='line'>  <span class="nx">_</span><span class="p">.</span><span class="nx">wrap</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">partial</span><span class="p">(</span><span class="nx">take</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nx">unsplat</span> <span class="p">)()</span>
</span><span class='line'><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//=&gt; 15</span>
</span><span class='line'><span class="nx">max_fancy</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>太过天马行空了，还是就此收笔吧！</p>

<h2>总结</h2>

<p>函数式编程就像搭积木一样，像<code>_.identity</code>、<code>_.partial</code>、<code>_.compose</code>、<code>splat</code>、<code>unsplat</code>等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。
越是简单的东西，蕴藏的越是更为无限的可能性。函数式编程是函数装配的艺术，是数据流动的艺术。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">俞乐</span></span>

      








  


<time datetime="2014-06-18T22:24:00+08:00" pubdate data-updated="true">2014年06月18日</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/javascript/'>javascript</a>
  
</span>


    </p>
    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/06/17/one-way-to-implement-pagination-folding-logic/" title="Previous Post: howdy">&laquo; howdy</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>文章分类</h1>
  <ul id="category-list"><li><a href='/blog/categories/javascript'>JAVASCRIPT (8)</a></li><li><a href='/blog/categories/photoshop'>PHOTOSHOP (2)</a></li><li><a href='/blog/categories/pragmatic'>PRAGMATIC (6)</a></li><li><a href='/blog/categories/python'>PYTHON (2)</a></li><li><a href='/blog/categories/sublime-text'>SUBLIME TEXT (4)</a></li></ul>
</section><section>
  <h1>近期文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/06/18/ponder-with-underscore-and-lodash/">由Underscore与Lodash的差异引发的思考</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/17/one-way-to-implement-pagination-folding-logic/">Howdy</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/01/venture-into-es6/">浅尝ECMAScript 6</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/17/touch-sublime-text-plugins/">触摸Sublime Text Plugins</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/16/pragmatic-sublime-text-snippets/">Sublime Text Snippets实用技巧二则</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/15/embrace-sublime-text-snippets/">拥抱Sublime Text Snippets</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/14/embrace-sublime-text/">情逗Sublime Text</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/09/closure-caveat-it-got-me/">闭包陷阱：我中招了！</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/15/alibaba-ued-quiz3-strategy/">淘宝前端之智勇大闯关第三季攻略</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/08/playing-zhao-cha-with-photoshop/">Photoshop趣味用法：玩转QQ找茬游戏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/04/import-this-and-caesar-cipher/">Import This 与恺撒密码</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/04/strategy-for-scheduling-javascript-asynchronous-code/">JavaScript异步代码排程策略</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/20/divide-slice-by-using-photoshop-scripts/">使用Photoshop: 将整图一分为九</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/19/file-batch-stuff/">文件批处理那些事儿</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>友情链接</h1>
  <ul>
    <li><a href="http://www.xiezongxing.com/">谢宗星博客</a></li>
    <li><a href="http://mengkang.net/">周梦康</a></li>
    <li><a href="http://bibodeng.sinaapp.com/">bibodeng</a></li>
    <li><a href="http://www.mapleshaw.com/">chrome丁</a></li>
  </ul>
</section>


<section>
    <h1>最近评论</h1>
    <div id="recentcomments" class="dsq-widget"><script type="text/javascript" src="http://myunlessor.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=48&excerpt_length=200"></script></div>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 俞乐 -
  <span class="credit">Proudly Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'myunlessor';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://myunlessor.me/blog/2014/06/18/ponder-with-underscore-and-lodash/';
        var disqus_url = 'http://myunlessor.me/blog/2014/06/18/ponder-with-underscore-and-lodash/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>

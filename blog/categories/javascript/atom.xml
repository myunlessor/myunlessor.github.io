<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章分类: javascript | Silent Reverie]]></title>
  <link href="http://myunlessor.me/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://myunlessor.me/"/>
  <updated>2014-06-19T22:59:12+08:00</updated>
  <id>http://myunlessor.me/</id>
  <author>
    <name><![CDATA[俞乐]]></name>
    <email><![CDATA[myunlessor@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[简单的分页折叠逻辑实现]]></title>
    <link href="http://myunlessor.me/blog/2014/06/19/one-way-to-implement-pagination-folding-logic/"/>
    <updated>2014-06-19T10:28:00+08:00</updated>
    <id>http://myunlessor.me/blog/2014/06/19/one-way-to-implement-pagination-folding-logic</id>
    <content type="html"><![CDATA[<p>列表数据量过多时，常见有以下两种呈现方式：</p>

<ul>
<li>将数据列表分页呈现</li>
<li>采用瀑布流形式加载数据</li>
</ul>


<p>本文单讲前者，即以分页方式呈现时分页折叠逻辑实现。</p>

<p>以往遇到需要分页的需求时，我一般采用项目中已经写好的公用组件直接用，或者利用第三方插件。观察这类代码的实现，有一个共同点：分页折叠逻辑和分页标签渲染是揉合在一块执行的。最近自己尝试着写了一个分页折叠逻辑实现，我把这部分逻辑从分页标签渲染中抽取出来了——我先处理分页折叠逻辑、再进而渲染分页标签。这么做有个好处：分页折叠逻辑和分页渲染处理实现解耦、职责区分，分页折叠逻辑代码的更换不会影响随后的渲染。</p>

<!-- more -->


<h2>思考过程</h2>

<p>假设我们的数据有15页，如果不考虑分页折叠逻辑的话，我们分页显示大概像这样：</p>

<pre><code class="js">//=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
_.range(1, 15 + 1)
</code></pre>

<p>我们可以对以上这个数组遍历渲染为标签。然而我们的页面横向空间有限，分页过多时，我们不希望将每一页都显示为标签。我们需要将跟当前页不太相干的页号折叠起来，不管数据有多少页，只显示固定可视页就好。比如，当前页为第7页，且最多显示9个槽位，我们希望显示成这样：</p>

<pre><code class="js">[1, '…', 5, 6, '7', 8, 9, '…', 15]
</code></pre>

<p>我们显示第一页、最末页以及与第7页相邻的页，其他页做折叠处理，即上述数组中的<code>…</code>，并且当前页显示为数字字符串以区分非当前页。</p>

<p>如果当前页是第2页呢？</p>

<pre><code class="js">[1, '2', 3, 4, 5, 6, 7, '…', 15]
</code></pre>

<p>如果当前页是第12页呢？</p>

<pre><code class="js">[1, '…', 9, 10, 11, '12', 13, 14, 15]
</code></pre>

<p>我们将分页折叠呈现用javascript的数组直接表示出来了，一切都很直观。既然这样，何不写个方法进行数组变换呢？我把这样的一个方法叫做<code>foldpages</code>：</p>

<pre><code class="js">/**
 * [foldpages description]
 * @param  {[Array]}  pages    [未作变换的分页数组]
 * @param  {[Number]} current  [当前显示页]
 * @param  {[Number]} viewsize [分页显示槽位个数]
 * @return {[Array]}           [分页折叠后的数组]
 */
function foldpages(pages, current, viewsize) {}

var pages = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
var viewsize = 9;

//=&gt; expected result: [1, '…', 5, 6, 7, 8, 9, '…', 15]
foldpages(pages, 7, viewsize);

//=&gt; expected result: [1, 2, 3, 4, 5, 6, 7, '…', 15]
foldpages(pages, 2, viewsize);

//=&gt; expected result: [1, '…', 9, 10, 11, 12, 13, 14, 15]
foldpages(pages, 12, viewsize);
</code></pre>

<p>剩下的就是实现了！</p>

<pre><code class="js">var foldpages = function (pages, current, viewsize) {
  var ret  = [].concat(pages),
      min  = 1,
      max  = ret.length,
      dots = '…',
      remain;

  current = Math.max(min, Math.min(current, max));

  if (max &lt;= viewsize) {
    ret[current - 1] = '' + ret[current - 1];
    return ret;
  }

  viewsize = Math.max(5, viewsize || 7);
  ret      = ['' + current];
  remain   = viewsize - 1;

  while (true) {
    var first = +ret[0], last = +ret[ret.length - 1];

    if (first &gt; min)  {
      ret.unshift(first - 1);
      if (!--remain) break;
    }

    if (last &lt; max) {
      ret.push(last + 1);
      if (!--remain) break;
    }
  }

  switch (true) {
  case +ret[0] === min:
    ret.splice(ret.length - 2, 2, dots, max);
    break;
  case +ret[ret.length - 1] === max:
    ret.splice(0, 2, min, dots);
    break;
  default:
    ret.splice(0, 2, min, dots);
    ret.splice(ret.length - 2, 2, dots, max);
    break;
  }

  return ret;
};
</code></pre>

<p>最后再验证下。</p>

<pre><code class="js">var TOTAL_PAGE = 15;
var pages = _.range(1, TOTAL_PAGE + 1);

_.each(_.range(6, 10 + 1), function (foldnum) {
  console.log('当显示槽位个数为' + foldnum + '时，每一页的折叠显示如下:');

  _.times(TOTAL_PAGE, function (index) {
    console.log(++index, foldpages(pages, index, foldnum));
  });

  console.log('\n');
});

// =============================================
// OUTPUT
// =============================================

/**
当显示槽位个数为6时，每一页的折叠显示如下:
 1 ["1", 2, 3, 4, "…", 15]
 2 [1, "2", 3, 4, "…", 15]
 3 [1, 2, "3", 4, "…", 15]
 4 [1, 2, 3, "4", "…", 15]
 5 [1, "…", 4, "5", "…", 15]
 6 [1, "…", 5, "6", "…", 15]
 7 [1, "…", 6, "7", "…", 15]
 8 [1, "…", 7, "8", "…", 15]
 9 [1, "…", 8, "9", "…", 15]
10 [1, "…", 9, "10", "…", 15]
11 [1, "…", 10, "11", "…", 15]
12 [1, "…", 11, "12", "…", 15]
13 [1, "…", 12, "13", 14, 15]
14 [1, "…", 12, 13, "14", 15]
15 [1, "…", 12, 13, 14, "15"]

当显示槽位个数为7时，每一页的折叠显示如下:
 1 ["1", 2, 3, 4, 5, "…", 15]
 2 [1, "2", 3, 4, 5, "…", 15]
 3 [1, 2, "3", 4, 5, "…", 15]
 4 [1, 2, 3, "4", 5, "…", 15]
 5 [1, "…", 4, "5", 6, "…", 15]
 6 [1, "…", 5, "6", 7, "…", 15]
 7 [1, "…", 6, "7", 8, "…", 15]
 8 [1, "…", 7, "8", 9, "…", 15]
 9 [1, "…", 8, "9", 10, "…", 15]
10 [1, "…", 9, "10", 11, "…", 15]
11 [1, "…", 10, "11", 12, "…", 15]
12 [1, "…", 11, "12", 13, 14, 15]
13 [1, "…", 11, 12, "13", 14, 15]
14 [1, "…", 11, 12, 13, "14", 15]
15 [1, "…", 11, 12, 13, 14, "15"]

当显示槽位个数为8时，每一页的折叠显示如下:
 1 ["1", 2, 3, 4, 5, 6, "…", 15]
 2 [1, "2", 3, 4, 5, 6, "…", 15]
 3 [1, 2, "3", 4, 5, 6, "…", 15]
 4 [1, 2, 3, "4", 5, 6, "…", 15]
 5 [1, 2, 3, 4, "5", 6, "…", 15]
 6 [1, "…", 4, 5, "6", 7, "…", 15]
 7 [1, "…", 5, 6, "7", 8, "…", 15]
 8 [1, "…", 6, 7, "8", 9, "…", 15]
 9 [1, "…", 7, 8, "9", 10, "…", 15]
10 [1, "…", 8, 9, "10", 11, "…", 15]
11 [1, "…", 9, 10, "11", 12, "…", 15]
12 [1, "…", 10, 11, "12", 13, 14, 15]
13 [1, "…", 10, 11, 12, "13", 14, 15]
14 [1, "…", 10, 11, 12, 13, "14", 15]
15 [1, "…", 10, 11, 12, 13, 14, "15"]

当显示槽位个数为9时，每一页的折叠显示如下:
 1 ["1", 2, 3, 4, 5, 6, 7, "…", 15]
 2 [1, "2", 3, 4, 5, 6, 7, "…", 15]
 3 [1, 2, "3", 4, 5, 6, 7, "…", 15]
 4 [1, 2, 3, "4", 5, 6, 7, "…", 15]
 5 [1, 2, 3, 4, "5", 6, 7, "…", 15]
 6 [1, "…", 4, 5, "6", 7, 8, "…", 15]
 7 [1, "…", 5, 6, "7", 8, 9, "…", 15]
 8 [1, "…", 6, 7, "8", 9, 10, "…", 15]
 9 [1, "…", 7, 8, "9", 10, 11, "…", 15]
10 [1, "…", 8, 9, "10", 11, 12, "…", 15]
11 [1, "…", 9, 10, "11", 12, 13, 14, 15]
12 [1, "…", 9, 10, 11, "12", 13, 14, 15]
13 [1, "…", 9, 10, 11, 12, "13", 14, 15]
14 [1, "…", 9, 10, 11, 12, 13, "14", 15]
15 [1, "…", 9, 10, 11, 12, 13, 14, "15"]

当显示槽位个数为10时，每一页的折叠显示如下:
 1 ["1", 2, 3, 4, 5, 6, 7, 8, "…", 15]
 2 [1, "2", 3, 4, 5, 6, 7, 8, "…", 15]
 3 [1, 2, "3", 4, 5, 6, 7, 8, "…", 15]
 4 [1, 2, 3, "4", 5, 6, 7, 8, "…", 15]
 5 [1, 2, 3, 4, "5", 6, 7, 8, "…", 15]
 6 [1, 2, 3, 4, 5, "6", 7, 8, "…", 15]
 7 [1, "…", 4, 5, 6, "7", 8, 9, "…", 15]
 8 [1, "…", 5, 6, 7, "8", 9, 10, "…", 15]
 9 [1, "…", 6, 7, 8, "9", 10, 11, "…", 15]
10 [1, "…", 7, 8, 9, "10", 11, 12, "…", 15]
11 [1, "…", 8, 9, 10, "11", 12, 13, 14, 15]
12 [1, "…", 8, 9, 10, 11, "12", 13, 14, 15]
13 [1, "…", 8, 9, 10, 11, 12, "13", 14, 15]
14 [1, "…", 8, 9, 10, 11, 12, 13, "14", 15]
15 [1, "…", 8, 9, 10, 11, 12, 13, 14, "15"]
*/
</code></pre>

<p>分页折叠逻辑实现好了，接下的的分页渲染就信手拈来，不费吹灰之力了！</p>

<h2>渲染分页</h2>

<p>直接上代码吧！</p>

<pre><code class="js">var renderpages = function (pages) {
  return _.map(pages, function (page) {
    switch (true) {
    case page === +page: return '&lt;a href="javascript:;"&gt;' + page + '&lt;/a&gt;';
    case page ==  +page: return '&lt;span class="current"&gt;' + page + '&lt;/span&gt;';
    default:             return '&lt;span&gt;' + page + '&lt;/span&gt;';
    }
  }).join('');
};

renderpages([1, '…', 5, 6, '7', 8, 9, '…', 15]);

//=============== OUTPUT ============&gt;
      '&lt;a href="javascript:;"&gt;1&lt;/a&gt;' +
      '&lt;span&gt;…&lt;/span&gt;' +
      '&lt;a href="javascript:;"&gt;5&lt;/a&gt;' +
      '&lt;a href="javascript:;"&gt;6&lt;/a&gt;' +
      '&lt;span class="current"&gt;7&lt;/span&gt;' +
      '&lt;a href="javascript:;"&gt;8&lt;/a&gt;' +
      '&lt;a href="javascript:;"&gt;9&lt;/a&gt;' +
      '&lt;span&gt;…&lt;/span&gt;' +
      '&lt;a href="javascript:;"&gt;15&lt;/a&gt;'
</code></pre>

<p>可以看到分页渲染时没有了分页折叠逻辑的干扰，代码清晰而简明了。我们一般都习惯把复杂的东西简单化。当然，要想要简单的事情变复杂化也是可行的。不信，我们以分页渲染为例，看能够将它复杂化到什么程度。</p>

<h2>简单的事情复杂化</h2>

<p>仍是直接上代码的方式。</p>

<pre><code class="js">function existy(x) { return x != null; }
function truthy(x) { return (x !== false) &amp;&amp; existy(x); }

function cat() {
  var head = _.first(arguments);
  return existy(head) ?
         head.concat.apply(head, _.rest(arguments)) : [];
}

function construct(head, tail) {
  return cat([head], _.toArray(tail));
}

//=&gt; [4, 8, 15, 16, 23, 42]
cat([4], [8, 15], [16, 23, 42]);

//=&gt; [4, 8, 15, 16, 23, 42]
construct(4, [8, 15, 16, 23, 42]);

function dispatch(/* funs */) {
  var funs = _.toArray(arguments), size = funs.length;

  return function (target /*, args */) {
    var ret = undefined, args = _.rest(arguments);

    _.detect(funs, function (fun) {
      ret = fun.apply(fun, construct(target, args));
      return existy(ret);
    });

    return ret;
  };
}

function whilst(cond, action) {
  return function (obj) {
    return truthy(cond(obj)) ? action(obj) : undefined;
  };
}

var renderer = dispatch(
  whilst(
    function (x) { return x === +x; },
    function (x) { return '&lt;a href="javascript:;"&gt;' + x + '&lt;/a&gt;'; }
  ),
  whilst(
    function (x) { return x == +x; },
    function (x) { return '&lt;span class="current"&gt;' + x + '&lt;/span&gt;'; }
  ),
  function (x) { return '&lt;span&gt;' + x + '&lt;/span&gt;'; }
);

var result = _.map([1, '…', 5, 6, '7', 8, 9, '…', 15], renderer).join('');
</code></pre>

<p>以上展示了如何用函数式编程方式把简单的事情复杂化。不过，它已背离了本文的宗旨，还是就此打住吧！</p>

<p>后记：想了好几种方式实现<code>foldpages</code>方法，天马行空的。然而，没有一种方式觉得很理想，包括贴在此处的这个！我想我是有代码洁癖症的，希望以后能想到更好的实现办法！这需要灵感：或是触类旁通的，或是恍然大悟的。</p>

<pre><code class="js">var inspiration = _.result(aspiration, action);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由Underscore与Lodash的差异引发的思考]]></title>
    <link href="http://myunlessor.me/blog/2014/06/18/ponder-with-underscore-and-lodash/"/>
    <updated>2014-06-18T22:24:00+08:00</updated>
    <id>http://myunlessor.me/blog/2014/06/18/ponder-with-underscore-and-lodash</id>
    <content type="html"><![CDATA[<p>自打接触<a href="http://underscorejs.org/">Underscore</a>以来就对其爱不释手，尔后又了解到<a href="http://lodash.com/">Lodash</a>。这两个类库为我们提供了一系列相当不错的跟函数式编程相关的方法。Underscore以API实现简洁著称。Lodash作为Underscore的后继者，除了对Underscore现有API功能使用上进行扩充外，更是添加了不少令人难忘的API，在性能上也更为出彩，而且还能根据需要构建自己的子集方法。相较而言，我更亲睐于Lodash，而且成了日常项目开发的标配。</p>

<p>目前Lodash的最新版本是v2.4.1，功能上可以说完全是Underscore的超集。只要Underscore添加了啥新功能时，Lodash都会及时覆盖更新，以维护它一如既往超集的地位。然而，当Underscore更新到v1.6.0时，这个版本添加了一个很棒的功能，其为方法<code>_.partial</code>添加了占位符参数的支持（如果没猜错的话，这个特性应该是从<a href="http://osteele.com/sources/javascript/functional/">functional.js</a>中移植过来了）。自然地，希望Lodash也能很快地对<code>_.partial</code>做增强处理。可是，四个月过去了，Lodash似乎处于冬眠状态，一点都不见有动静。于是乎，到目前为止，Lodash的功能不足以完全覆盖Underscore了，于是也就有了这篇文章。</p>

<!-- more -->


<h2>循序渐进</h2>

<p>还是以例子引入话题，假如我要将数组<code>['4', '8', '15', '16', '23', '42']</code>(<a href="http://www.douban.com/group/topic/6251101/">神奇数字</a>)中所有字符串元素变换为数字型。不假思索后，我们会这样写：</p>

<pre><code class="js">//=&gt; [4, 8, 15, 16, 23, 42]
_.map(['4', '8', '15', '16', '23', '42'], function (val) {
  return Number(val);
});
</code></pre>

<p>没错，这没什么问题。稍微观察一下，我们会发现，传递给<code>_.map</code>方法的匿名回调方法仅仅做了件简单的事，将其第一个参数传进<code>Number</code>函数中调用后直接返回。这种做法其实就相当于：你实际要执行的是<code>f</code>函数，而你却通过调用<code>g</code>函数间接执行<code>f</code>函数，而事实上你完全可以直接执行<code>f</code>函数的，如下所示：</p>

<pre><code class="js">var f = function (val) { return val; };
var g = function (val) { return f(val); };

//=&gt; true
f('stupid') === g('stupid');
</code></pre>

<p>因此，上述数组变换实际可以简化为：</p>

<pre><code class="js">//=&gt; [4, 8, 15, 16, 23, 42]
_.map(['4', '8', '15', '16', '23', '42'], Number);
</code></pre>

<p>嗯，确实是这么回事^-^。</p>

<p>再比如，我想将数组<code>['1NO', '2FOOL', '3ME']</code>中所有字符串元素解析为数字型。我们知道将字符串解析为数字型可以通过<code>parseInt</code>直接得到，像这样：</p>

<pre><code class="js">var first = parseInt('1NO');     //=&gt; 1
var middle = parseInt('2FOOL');  //=&gt; 2
var last = parseInt('3ME');      //=&gt; 3
</code></pre>

<p>It works! 于是以迅雷不及掩耳的速度得出结果：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map(['1NO', '2FOOL', '3ME'], function (val) {
  return parseInt(val);
});
</code></pre>

<p>Perfect！细看一下，咿，这不是和之前那个例子一样的嘛，这次学聪明了，窃喜之下后马上将结果改为如下，也没忘夸奖下自己随机应变的能力：</p>

<pre><code class="js">//=&gt; [1, NaN, NaN]
_.map(['1NO', '2FOOL', '3ME'], parseInt);
</code></pre>

<p>等等，我勒个去，结果不符合预期了，这是怎么回事？！</p>

<p>脑袋稍微转下，原来是这么回事，当你把<code>parseInt</code>直接作为<code>_.map</code>方法的回调时，<code>parseInt</code>执行的时候实际是传入了三个参数(元素值，元素索引，数组本身)。
所以上述代码实际等价于：</p>

<pre><code class="js">var ary = ['1NO', '2FOOL', '3ME'];

//=&gt; [1, NaN, NaN]
_.map(ary, function (val, idx, ary) {
  return parseInt(val, idx, ary);
});

var first = parseInt('1NO', 0, ary);     //=&gt; 1
var middle = parseInt('2FOOL', 1, ary);  //=&gt; NaN
var last = parseInt('3ME', 2, ary);      //=&gt; NaN
</code></pre>

<p><code>parseInt</code>调用时可接收可选的第二个参数，元素索引值作为第二个参数无形中传入到<code>parseInt</code>，呜呼哀哉！第一个例子为什么没问题？因为Number只接收一个参数，而把其后的所有参数都忽略，所以安然无恙。这么看来<code>Explicit is better than implicit(显优于隐)</code>的确是真理啊！</p>

<p>在此，我不想弹劾<code>parseInt</code>直接作为<code>_.map</code>回调使用的情况，我只想吐嘈下<code>parseInt</code>不显式指定第二个参数调用的隐患。MDN上关于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt API</a>的定义是强调指明要传入<code>radix(基数)</code>值作为解析数字的依据的。</p>

<p>除此以外，我想强调的是<code>Number</code>和<code>parseInt</code>是否有<code>共同特征(pattern recognition)</code>值得我们去挖掘的呢？答案是有的。<code>_.map</code>遍历数组元素时，其都是将数组元素传入到<code>Number</code>或<code>parseInt</code>作为其第一个参数进行执行的。而这是函数式编程很重要的一个特点，对函数进行<code>柯里化(curry)</code>或<code>偏应用(partial)</code>处理时，传给函数的第一个参数往往是数据流，<code>数据流(data flow)</code>也是函数式编程不同于<code>控制流(control flow)</code>的非函数式编程的一个显著区别。</p>

<p>回到之前的问题，既然<code>parseInt</code>不能直接作为<code>_.map</code>回调处理，而我又不想使用匿名函数间接调用<code>parseInt</code>的刻板方法，那么还有其他办法吗？答案是有的。</p>

<p>试想，我们遇到的问题是<code>parseInt</code>作为<code>_.map</code>回调执行时，无形中其第二个参数被污染了。反过来想，我们要找到一个办法使得其第二个参数免受污染。所幸的是，Underscore v1.6.0版本中提供的<code>_.partial</code>正好能满足这一需求。</p>

<p>我的想法是，利用<code>_.partial</code>对<code>parseInt</code>进行偏应用处理，返回得到的新函数再作为回调传入<code>_.map</code>中，如下所示：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map(['1NO', '2FOOL', '3ME'], _.partial(parseInt, _, 10));
</code></pre>

<p>在这个例子中，我们为<code>parseInt</code>预填充了两个参数：第一个参数传入<code>_</code>代表参数占位符，它是动态值；第二个传入基数值10，它是不变的，这样我们就将其第第二个参数“锁定”了。当<code>_.map</code>回调函数被执行时，它还是依次接收三个参数回来，只不过这次接收的第一个参数（数组元素作为数据填补）代替了参数占位符的位置，第二、三个参数被依次追加到<code>parseInt</code>末尾而被忽略，于是我们的代码正常工作了。</p>

<p>然而，这行代码Underscore v1.6.0+版本中才有效，对于Lodash或更低版本的Underscore，我们该怎么办呢？这时函数柯里化的威力就体现出来了。因为<code>parseInt</code>接收两个参数，于是我构建如下的二级柯里化函数：</p>

<pre><code class="js">function curry2(fun) {
  return function (second) {
    return function (first) {
      return fun(first, second);
    };
  };
}
</code></pre>

<p>函数<code>curry2</code>调用时接收一个希望被柯里化的函数作为参数传入，方法体中返回一个匿名函数，接收单一参数，而在匿名函数中又再次返回一个匿名函数，同样接收单一参数，直到柯里化函数执行两次时，被柯里化的函数得以执行，两级柯里化参数逆序传入而返回。</p>

<p>应用到这个例子，即：我们对<code>parseInt</code>进行柯里化处理，执行一次传入参数10，也是预填充第二个参数，结果返回新的函数等待<code>_.map</code>被执行时将第一个参数传递进行而返回结果值，代码如下：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map(['1NO', '2FOOL', '3ME'], curry2(parseInt)(10));
</code></pre>

<p>在这个妥协的解决方法里，我们借助了自己构建的柯里化函数作为辅助。这不禁让我这么想：难道在这泱泱几十号工具方法中，在这个问题上一无是处，无一能为我所用，反倒要依赖外援？思考片刻后，依照<code>curry2</code>的思路，想到Lodash不是提供有<code>_.partialRight</code>方法嘛！从左往右填充参数不行，那就从右往左介入。就像<code>curry2</code>那样给<code>parseInt</code>预填充第二个参数，然后等待<code>_.map</code>填充第一个参数后执行，于是写了如下代码：</p>

<pre><code class="js">//=&gt; [1, NaN, NaN]
_.map(['1NO', '2FOOL', '3ME'], _.partialRight(parseInt, 10));
</code></pre>

<p>结果不尽如人意，和<code>parseInt</code>直接作为<code>_.map</code>回调函数传入时结果没什么两样，执行时<code>parseInt</code>仍是被<code>_.map</code>传回来的多余参数污染了，基数10成为了<code>parseInt</code>的末尾参数而直接忽略了。多余？这给我提了个醒，如果我能将<code>_.map</code>传回来的多余的后两参数过滤掉，那么<code>parseInt</code>被执行时作为基数10的末尾参数是不是就是作为其第二个参数传入而正常了。Great！现在的问题变成了如何将<code>_.map</code>传回来的多余的后两参数过滤掉？思考良久后我辗转想到了<code>_.identity</code>。<code>_.identity</code>应该算Lodash中倒数第二简单的方法了吧，最简单的是<code>_.noop</code>，它们各自定义如下所示：</p>

<pre><code class="js">_.noop = function () {};
_.identity = function (val) { return val; };
</code></pre>

<p>简单的东西并非一无是处。麻雀虽小，五脏俱全。有时候往往是简单的东西才是我们需要的东西。咋一看，<code>_.identity</code>不就是你给它什么输入，它就给你返回什么嘛。可是当你换个角度想，你却发现了别样的东西，直接上代码：</p>

<pre><code class="js">_.identity('I');                  //=&gt; 'I'
_.identity('I', 'FOOL');          //=&gt; 'I'
_.identity('I', 'FOOL', 'YOU');   //=&gt; 'I'
</code></pre>

<p>发现了什么？所以，更准确地说，无论你给<code>_.identity</code>传入多少个参数，结果都是返回给你传入的第一个参数。这样一想，我传三个参数给它，结果它只把第一个参数返回了，剩余那两个参数呢？消失在茫茫人海之中，不见了。Good Job！</p>

<p>好了，现在解决了参数过滤的问题，我该怎么把过滤后存活下来的第一个参数传给<code>partial right</code>后的<code>parseInt</code>函数使用呢。我们需要管道进行衔接，一个函数的输出作为接下来另一个函数的输入，<code>_.compose</code>不正是专门做这事的嘛，Yeah！</p>

<p>假设<code>f</code>和<code>g</code>是两函数，<code>f</code>函数调用后的输出作为<code>g</code>函数的输入，其中<code>x</code>是<code>f</code>的输入值，则以下等式是成立的：</p>

<pre><code class="js">//=&gt; true
_.isEqual( g(f(x)), _.compose(g, f)(x) );
</code></pre>

<p>有了以上的分析后，我们通过<code>_.compose</code>作为纽带将<code>partial right</code>后的<code>parseInt</code>和<code>_.identity</code>衔接起来，最终得到答案：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map( ['1NO', '2FOOL', '3ME'], _.compose( _.partialRight(parseInt, 10), _.identity ) );
</code></pre>

<p>看到以上这行代码，你在脑海中涌动的应该就是数据在各个函数间依次流动着而最终得到结果，即函数式编程的<code>数据流(data flow)</code>思想。我并不是倡导在实际工作中要写这种代码，更多的是体会函数式编程的思维，那种自成一体的曼妙。函数式编程的思想表现的不是<code>MARVEL</code>旗下的那些个个人英雄主义气概，而是各个功能单一的函数组合在一起才能体现的威力。</p>

<h2>思维发散</h2>

<p>另一个例子：将数组<code>['left  ', ' center ', '  right']</code>中各个字符串元素两边的空白符去除，长驱直入：</p>

<pre><code class="js">//=&gt; ['left', 'center', 'right']
_.map(['left  ', ' center ', '  right'], function (s) {
  return s.trim();
});
</code></pre>

<p>仔细看这段代码，你会看到另一种模式，匿名函数里返回的是第一个参数调用某个方法的结果。函数式编程的核心是函数，而不是方法。我们要将方法调用转化为函数调用，才更能体现函数式风格。Underscore和Lodash都提供了<code>_.result</code>方法。通过这个方法我们可以将方法调用转化为函数调用，也即：</p>

<pre><code class="js">var str = ' center ';

//=&gt; true
str.trim() === _.result(str, 'trim');
</code></pre>

<p><code>_.result</code>调用像不像此前的<code>parseInt</code>？这样，我们之前的方法再次奏效：</p>

<pre><code class="js">var ary = ['left  ', ' center ', '  right'];

// Underscore v1.6.0
_.map(ary, _.partial( _.result, _, 'trim' ));

// Lodash v2.4.1
_.map(ary, _.compose( _.partialRight( _.result, 'trim' ), _.identity ));

// Underscore &amp; Lodash
_.map(ary, curry2( _.result )( 'trim' ));
</code></pre>

<h2>延伸拓展</h2>

<p>前面提到了<code>_.identity</code>方法，如果换种角度来看，可以把它当作参数过滤器使用。可是它是有局限性的，它只能过滤第一个参数。假如某种情况下我要过滤出输入参数的前两个参数，这回该怎么办？我们知道函数只能返回一个值，要返回多个值的话，则可以将多个值以数组形式返回。以下是过滤前两个参数的代码：</p>

<pre><code class="js">function take2(first, second) {
  return [first, second];
}

//=&gt; ['first', 'second']
take2('first', 'second', 'third');

//=&gt; ['first', 'second']
take2('first', 'second', 'third', 'forth');
</code></pre>

<p>解决了过滤两个参数的问题，可是它有个瑕疵，它的输出是以数组形式返回的。如果这种输出直接作为另一个函数的输入，这将无法衔接起来，因为我们的接收方函数要求参数是单个单个传入，而不是给它灌入单个数组。于是，我们接下来需要某种能够将数组变换为单个单个参数传入接收方函数的方法。</p>

<p>先看以下举例：</p>

<pre><code class="js">function max(/* args */) {
  return Math.max.apply(Math, arguments);
}

//=&gt; 42
max(8, 4, 15, 42, 23, 16);
</code></pre>

<p><code>max</code>方法很简单，它返回任意输入Number型参数的最大值。给它输入的单个单个参数依次是<code>8, 4, 15, 42, 23, 16</code>。现在假设我只想知道输入参数的前两个哪个最大。我们脑海里首先闪过的可能是如下答案：</p>

<pre><code class="js">function max_initial(first, second) {
  return max(first, second);
}

//=&gt; 8
max_initial(8, 4, 15, 42, 23, 16);
</code></pre>

<p>看起来还不错！但我们前面定义了专门充当“参数过滤器”的函数<code>take2</code>，让我们试图将它介入其中，像如下那样：</p>

<pre><code class="js">function max_initial2(/* args */) {
  return max.apply(null, take2.apply(null, arguments));
}

//=&gt; 8
max_initial2(8, 4, 15, 42, 23, 16);
</code></pre>

<p>感谢<code>Function.prototype.apply</code>方法，我们成功地将参数过滤了，并传给了<code>max</code>，It Works！可是盯着它看下，怎么看怎么不舒服。还是再改进下吧～前面我们提到<code>_.compose</code>方法可以将参数输入输出串联起来，那再试图让<code>_.compose</code>介入进来吧！</p>

<pre><code class="js">var max_initial3 = _.compose(max, take2);

//=&gt; NaN
max_initial3(8, 4, 15, 42, 23, 16);
</code></pre>

<p>Does it work？Nope！Why？<code>max_initial3</code>函数执行实际等价于如下代码：</p>

<pre><code class="js">//=&gt; [8, 4]
var result = take2(8, 4, 15, 42, 23, 16);

//=&gt; NaN
max(result);
</code></pre>

<p>我们将<code>take2</code>执行后返回的数组值直接传递给了<code>max</code>，而<code>max</code>需接收的是单个单个的参数。由于接口的不一致，我们的尝试失败了。既然接口不一致，我们何不制造个<code>适配器(Adapter)</code>以适配接口呢！我们需要什么样的适配器？我们需要将数组参数转化为单个单个参数的适配器——我们需要<code>splat</code>适配器：</p>

<pre><code class="js">function splat(fun) {
  return function (array) {
    return fun.apply(null, array);
  };
}

var maxAdapted = splat(max);

//=&gt; 8
maxAdapted([8, 4]);
</code></pre>

<p>Looks pretty neat, doesn&rsquo;t it?有了适配器后，我们再用<code>_.compose</code>将它们衔接起来：</p>

<pre><code class="js">var max_initial4 = _.compose(splat(max), take2);

//=&gt; 8
max_initial4(8, 4, 15, 42, 23, 16);
</code></pre>

<p>瞧，它又正常工作了，多亏了<code>splat</code>适配器。适配器用于适配不同的接口，以此将不同的接口衔接起来，它的职责是单一的，因此也可以复用。</p>

<p>现在我们有了将数组参数转化为单个单个参数的<code>splat</code>适配器。反过来，我们何不再制造个将单个单个参数转化为数组参数的适配器呢？我们估且叫它<code>unsplat</code>吧！</p>

<pre><code class="js">function unsplat(fun) {
  return function () {
    return fun.call(null, [].slice.call(arguments));
  };
}

// 既然我们使用Underscore或Lodash，我们何不写成这样呢！
function unsplat(fun) {
  return function () {
    return fun.call(null, _.toArray(arguments));
  };
}
</code></pre>

<p><code>unsplat</code>能用在什么地方呢？Let&rsquo;s have a try!</p>

<p>前面我们定义有<code>take2</code>，我们何不定义个更一般的<code>take</code>函数呢？</p>

<pre><code class="js">function take(n, array) {
  return array.slice(0, n);
}

//=&gt; [8, 4]
take(2, [8, 4, 15, 42, 23, 16]);
</code></pre>

<p>有了更一般的<code>take</code>函数，我们就可以基于它生成过滤任意多个前置参数的“参数过滤器”函数了。</p>

<pre><code class="js">var take2 = _.partial(take, 2);
var take3 = _.partial(take, 3);

//=&gt; [8, 4]
take2([8, 4, 15, 42, 23, 16]);

//=&gt; [8, 4, 15]
take3([8, 4, 15, 42, 23, 16]);
</code></pre>

<p>这不对！之前我们调用<code>take2</code>的时候传递给它的是单个单个的参数，可是这回调用时传递的却是数组参数。不行，我们需要适配器，我们需要将单个单个参数转化为数组参数的适配器——我们需要<code>unsplat</code>适配器！</p>

<pre><code class="js">var take2 = unsplat(_.partial(take, 2));
var take3 = unsplat(_.partial(take, 3));

//=&gt; [8, 4]
take2(8, 4, 15, 42, 23, 16);

//=&gt; [8, 4, 15]
take3(8, 4, 15, 42, 23, 16);
</code></pre>

<p>这回正常了！回到最初的问题，针对<code>max</code>函数，给它输入的单个单个参数依次是<code>8, 4, 15, 42, 23, 16</code>。现在假设我只想知道输入参数的前三个哪个最大，我们有了一般性的答案：</p>

<pre><code class="js">var max_revamped = _.compose( splat(max), unsplat( _.partial(take, 3) ) );

//=&gt; 15
max_revamped(8, 4, 15, 42, 23, 16);
</code></pre>

<p>Now everything is under control! 如果我们了解<code>_.wrap</code>方法，我们可以做的更疯狂：</p>

<pre><code class="js">var max_fancy = _.compose(
  _.wrap( max, splat )(),
  _.wrap( _.partial(take, 3), unsplat )()
);

//=&gt; 15
max_fancy(8, 4, 15, 42, 23, 16);
</code></pre>

<p>太过天马行空了，似乎偏离主旨了。。。还是就此收笔吧！</p>

<h2>总结</h2>

<p>函数式编程就像搭积木一样，像<code>_.identity</code>、<code>_.partial</code>、<code>_.compose</code>、<code>splat</code>、<code>unsplat</code>等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。
越是简单的东西，蕴藏的越是更为无限的可能性。</p>

<p>最后，我的感悟是：函数式编程以数据流动为导向，是函数装配的艺术。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅尝ECMAScript 6]]></title>
    <link href="http://myunlessor.me/blog/2014/03/01/venture-into-es6/"/>
    <updated>2014-03-01T10:43:00+08:00</updated>
    <id>http://myunlessor.me/blog/2014/03/01/venture-into-es6</id>
    <content type="html"><![CDATA[<p>现在ECMAScript 6草案制定在不断地推进，浏览器们也在跟进实现，了解ES6的提供的诸多特性是势在必行的事了。</p>

<p>有关浏览器们对ECMAScript 6草案的实现情况可参阅<a href="http://kangax.github.io/es5-compat-table/es6/">这里</a>。</p>

<p>有关ES6的语言特性可参阅<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures">这里</a>。</p>

<p>目前对ES6实现较为充分的环境有<a href="https://github.com/google/traceur-compiler">Google Traceur Compiler</a>及<a href="http://nightly.mozilla.org/">Firefox Nightly</a>。</p>

<p>有关<code>traceur compiler</code>的环境配置如下：</p>

<p>```html</p>

<script src="https://traceur-compiler.googlecode.com/git/bin/traceur.js"></script>


<script src="https://traceur-compiler.googlecode.com/git/src/bootstrap.js"></script>


<script>
traceur.options.experimental = true;
</script>


<script>
  // blablabla...
</script>


<p>```</p>

<!-- more -->


<h2>I、新的语法</h2>

<h3>1. 块作用域(Block Scope)</h3>

<p><code>var</code>关键字声明的变量具有函数作用域或全局作用域，而通过<code>let</code>关键字将变量声明为块作用域，对比如下：</p>

<pre><code class="js">// 在块(curly)作用域中声明并初始化变量
{ var foo = 'foo'; }
{ let bar = 'bar'; }

console.log(foo); // -&gt; 'foo'
console.log(bar); // ReferenceError: bar is not defined
</code></pre>

<h3>2. 常量(Constants)</h3>

<p>许多语言都有常量的概念(值不能改变的变量)。ES6草案将常量引入到了JavaScript中。</p>

<p>使用<code>const</code>关键字将变量声明为常量，规范要求<code>const</code>声明的常量具块作用域，某些浏览器目前将其实现为函数作用域或全局作用域。声明变量为常量时如果不赋值，某些浏览器会将该变量赋<code>undefined</code>值，而某些浏览器则直接报错。为常量重新赋值，某些浏览器会忽略新赋值，某些浏览器会报错。将引用类型（如数组或对象）声明为常量，并不影响引用类型的扩充行为：</p>

<pre><code class="js">const noexist;             // Const must be initialized (IE)
const foo = 'foo';
foo = 'hoo';               // Assignment to const (IE)
console.log(foo);          // -&gt; 'foo'

// 常量引用类型并不影响对其自身的扩充(`augument`)
const bar = [];
bar.push('spam', 'eggs');
console.log(bar.length);   // -&gt; 2

// 同上
const baz = {};
baz.spam = 'eggs';
console.log(baz.spam);     // -&gt; 'eggs'
</code></pre>

<h3>3. 默认参数(Default Parameters)</h3>

<p>函数声明时可以为参数赋予默认值，这样函数调用时如果参数缺省(<code>undefined</code>)，则该参数会被赋予默认值，使用默认参数在一定程序上使函数声明更为直观，并且简化我们的代码。</p>

<pre><code class="js">// 传统写法
function fill(container, liquid) {
  if (typeof liquid === 'undefined') {
    liquid = 'coffee';
  }
  // blablabla...
}

// 新式写法
function fill(container, liquid = 'coffee') {
  // blablabla...
}
</code></pre>

<h3>4. Rest和Spread操作符</h3>

<p>很多时候我们处理函数的时候需要用到数组参数，ES6提供的<code>Rest</code>和<code>Spread</code>操作符可以让我们更方便地处理数组参数。</p>

<p><code>rest</code>是将多值折叠为单值集合的过程，和<code>rest</code>相反，<code>spread</code>是将单值集合展开为多值的过程。很多语言都有对它的支持，语法略有差异，Python、Ruby和CoffeeScript将这种语法统称为<code>splats</code>，Python和Ruby用形如<code>*var</code>的语法来表达。CoffeeScript用形如<code>var...</code>的语法来表达，而ES6则用形如<code>...var</code>的语法来表达。</p>

<pre><code class="js">// 1. rest
function unary(...first) {
  console.log(first);
}

function binary(first, ...rest) {
  console.log([first, rest]);
}

unary('foo');                 // -&gt; ['foo']
unary('foo', 'bar');          // -&gt; ['foo', 'bar']

binary('foo');                // -&gt; ['foo', []]
binary('foo', 'bar', 'baz');  // -&gt; ['foo', ['bar', 'baz']]

// rest实现
;(function (window, undefined) {
  var _slice = Array.prototype.slice;

  function variadic(fn) {
    var numParams    = fn.length, // 形参个数
        numNamedArgs = numParams - 1;


    return numParams &lt; 1 ? fn : function () {
      var
        numArgs             = arguments.length, // 实参个数
        namedArgs           = _slice.call(arguments, 0, numNamedArgs),
        numMissingNamedArgs = Math.max(0, numNamedArgs - numArgs),
        argPadding          = Array(numMissingNamedArgs),
        variadicArgs        = _slice.call(arguments, numNamedArgs);

      return fn.apply(this, namedArgs
                              .concat(argPadding)
                              .concat([variadicArgs]));
    };
  }

  window.variadic = variadic;
}).call(this, this);

// -&gt; ['why', 'hello', 'there']
variadic(unary)('why', 'hello', 'there');

// -&gt; ['why', ['hello', 'there']]
variadic(binary)('why', 'hello', 'there');

// ----------------------------------------------------

// 2. spread
var numbers = [1, 2, 3, 4, 5];

// 传统写法
var max = Math.max.apply(Math, number);

var filled = numbers.slice(0);
[].push.apply(filled, [6, 7, 8, 9, 10]);

// 新式写法
var max = Math.max(...number);
var filled = [...numbers, 6, 7, 8, 9, 10]
</code></pre>

<h3>5. 解构赋值(Destructuring Assignment)</h3>

<p>如果你想从数组中拿取多个元素并赋予其他变量，或是从函数中返回多值，那么ES6提供的<code>解构赋值(Destructuring Assignment)</code>特性正是我们所需要的。</p>

<pre><code class="js">// 1. 数组解构赋值
let a = 1, b = 2;
[b, a] = [a, b];   // swap two variabls

console.log(a, b); // -&gt; 2 1

function dest() {
  return ['why', 'hello', 'there'];
}

let [foo, bar, baz] = dest();

// -&gt; 'why' 'hello' 'there'
console.log(foo, bar, baz);

// 忽略不需要的值
let [a, , c] = dest();

// -&gt; 'why' 'there'
console.log(a, c);

// 2. 对象解构赋值
let janeDoe = {
  first: 'jane',
  last: 'doe',
  gender: 'female',
  hobbies: ['music', 'sports']
};

let { first: firstName, last: lastName } = janeDoe;

// -&gt; 'jane' 'doe'
console.log(firstName, lastName);

let { first, last } = janeDoe;

// -&gt; 'jane' 'doe'
console.log(first, last);

function whatever({ first: f, last: l }) {
  console.log(f, l);
}

// -&gt; 'jane' 'doe'
whatever(janeDoe);

function another({ gender, hobbies: [hob1, hob2] }) {
  console.log(gender, hob1, hob2);
}

// -&gt; 'female' 'music' 'sports'
another(janeDoe);
</code></pre>

<h3>6. for…of 循环语句</h3>

<p>ES6新引入了<code>for…of</code>循环语句，以往我们使用的<code>for..in</code>循环语句用于迭代对象的<code>属性(properties)</code>，而新式的for…of循环语句则用于迭代对象的<code>值(values)</code>。</p>

<pre><code class="js">var numbers = [1, 2, 3, 4, 5];

// 传统写法
numbers.forEach(function (number) {
  console.log(number);
});

// 新式写法
for (let number of numbers) {
  console.log(number);
}
</code></pre>

<h3>7. 迭代器(Iterators)</h3>

<p><code>for..of</code>循环只对迭代对象有效，这意味着要使一个对象可迭代，对象自身需要迭代器。具体可移步参阅<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures#wiki-iterators-and-for-of-loops">这里</a></p>

<h3>8. 生成器(Generators)</h3>

<p>生成器可以创建迭代器，并且可以用它来创建自定义迭代对象。生成器异常强大，网上你可以找到它联合<code>Promises</code>一起使用的情形，它为ajax异步调用开启一个新的世界，一个没有<code>callbacks</code>，没有<code>then</code>的世界，它的强大会超乎你的想象。</p>

<pre><code class="js">// 基本用法
function* numberGen() {
  let limit = 3, i = 0;

  do {
    yield i++;
  } while (i &lt; limit);
}

let iter = numberGen();

// -&gt; { value: 0, done: false }
iter.next();

// -&gt; { value: 1, done: false }
iter.next();

// -&gt; { value: 2, done: false }
iter.next();

// -&gt; { value: undefined, done: true }
iter.next();

// 过滤偶数
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

function* even(numbers) {
  for (let n of numbers) {
    if (n % 2 === 0) {
      yield n;
    }
  }
}

for (let n of even(numbers)) {
  console.log(n);
}

// 延伸用法1
let janeDoe = {
  first: 'jane',
  last: 'doe'
};

function* iterObj(obj) {
  for (let prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      yield [prop, obj[prop]];
    }
  }
}

// -&gt; "first: jane"
// -&gt; "last: doe"
for (let [key, value] of iterObj(janeDoe)) {
  console.log([key, value].join(': '));
}

// 延伸用法2
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Person.prototype.greeting = function (name) {
  return 'Hello, ' + name;
};

// Person.prototype[Symbol.iterator]
Person.prototype['@@iterator'] = function* () {
  for (let prop in this) {
    if (this.hasOwnProperty(prop)) {
      yield [prop, this[prop]];
    }
  }
};

let johndoe = new Person('john', 'doe');

// -&gt; "first: john"
// -&gt; "last: doe"
for (let [key, value] of johndoe) {
  console.log([key, value].join(': '));
}
</code></pre>

<h3>9. Comprehensions</h3>

<p>Python最早引入了<code>List Comprehensions(列表推导)</code>的概念，这一特性深受程序员的喜爱，这一特性继而引申出<code>Dict Comprehensions</code>及<code>Generator Comprehensions</code>。CoffeeScript设计时也参考了Python，它也有<code>Comprehensions</code>的概念。而作为日渐流行的JavaScript，这么好的东西怎么能错过呢？自然而然地它也成为了JavaScript的标配。
我们在操作数组的时候经常会使用<code>Array.prototype.map</code>和<code>Array.prototype.filter</code>方法，ES6为我们提供的<code>Comprehensions</code>简直可以称为这两个方法提供<code>语法糖(syntax sugar)</code>，其语法表达直白、简明、形象。</p>

<pre><code class="js">let fruits = ['apple', 'orange', 'banana'];

// 传统应用
let ripeFruits = fruits.map(function (item) {
  return 'ripe ' + item;
});

let fruitsWithN = fruits.filter(function (item) {
  return item.indexOf('n') &gt; -1;
});

console.log(ripeFruits);
console.log(fruitsWithN);

// 新式玩法
// 1. 数组推导(Array Comprehension)
let ripeFruits2 = ['ripe ' + item for (item of fruits)];
let fruitsWithN2 = [item for (item of fruits) if (item.indexOf('n') &gt; -1)];
let ripeFruitsWithN = ['ripe ' + item for (item of fruits) if (item.indexOf('n') &gt; -1)];

console.log(ripeFruits2);
console.log(fruitsWithN2);
console.log(ripeFruitsWithN);

// 2. 生成器推导(Generator Comprehension)
let iter = ('ripe ' + item for (item of fruits) if (item.indexOf('n') &gt; -1));
console.log(iter.next()); // -&gt; "ripe orange"
console.log(iter.next()); // -&gt; "ripe banana"
</code></pre>

<h3>10. 箭头函数(Arrow Functions)</h3>

<p>有关ES6箭头函数的介绍移步<a href="http://www.nczonline.net/blog/2013/09/10/understanding-ecmascript-6-arrow-functions/">这里</a>参阅。</p>

<h2>II、新的代码组织方式</h2>

<h3>1. 类(Classes)</h3>

<p>移步<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures#wiki-classes">这里</a>以及<a href="http://www.nczonline.net/blog/2012/10/16/does-javascript-need-classes/">这里</a>进行参阅。</p>

<h3>2. 模块(Modules)</h3>

<p>移步<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures#wiki-modules">这里</a>进行参阅。</p>

<h2>III、新的标准类库</h2>

<h3>1. 集合(Set)</h3>

<p>Python的作者是个数学家，所以这门语言早期就有了对<code>Set</code>的支持。现在，ES6也将<code>Set</code>纳为标配了。有了集合，数组去除已然不费吹灰之力了。
更详细的介绍请移步<a href="http://www.nczonline.net/blog/2012/09/25/ecmascript-6-collections-part-1-sets/">这里</a>。</p>

<pre><code class="js">// 创建集合实例
let items = new Set([1, 2, 2, 3, 4, 3, 5, '2']);

// 判断指定元素是否在集合中
console.log(items.has('2'));

// 遍历集合元素
for (let item of items) {
  console.log(item);
}

// 添加元素到集合中
items.add(6);

// 从集合中移除元素
items.delete(1);

// 获取集合里元素个数
console.log(items.size);

// 遍历集合元素
for (let item of items) {
  console.log(item);
}

// 移除集合里所有元素
items.clear();
</code></pre>

<h3>2. 映射(Map)</h3>

<p>以往我们都是使用字面对象构建键值对映射，ES6提供的<code>Map</code>结构提供了友好直白的API让我们可以更好地操纵键值对，就像<code>localStorge</code>一样，它使我们更好地在客户端保存数据。
更详细的介绍请移步<a href="http://www.nczonline.net/blog/2012/10/09/ecmascript-6-collections-part-2-maps/">这里</a>。</p>

<pre><code class="js">// 创建映射实例
let stuff = new Map();

// 设置键值对
stuff.set('foo', 'bar')
// 你没看错，对象也可以作为Map的key
stuff.set(document, document.createElement('div'));

// 判断是否设置了指定键
console.log(stuff.has('foo'));

// 获取键值对个数
console.log(stuff.size);

// 获取指定键的值
console.log(stuff.get('foo'));

// 删除指定的键
stuff.delete('foo');

// 清除所有键
stuff.clear();

// 遍历键值对
for (let item of stuff) {
  // key = item[0];
  // value = item[1];
  // do something
}

// 同上
for (let item of stuff.items()) {
  // do something
}

// 同上(解构赋值)
for (let [key, value] of stuff) {
  // do something
}

// 遍历所有键
for (let key of stuff.keys()) {
  // do something
}

// 遍历所有值
for (let value of stuff.values()) {
  // do something
}
</code></pre>

<h3>2. 弱映射(WeakMap)</h3>

<p><code>WeakMap</code>和<code>Map</code>类似，但<code>WeakMap</code>的键只能为对象，而不能为原始类型。
有关<code>WeakMap</code>的详细的介绍请移步<a href="http://www.nczonline.net/blog/2012/11/06/ecmascript-6-collections-part-3-weakmaps/">这里</a>以及<a href="http://www.nczonline.net/blog/2014/01/21/private-instance-members-with-weakmaps-in-javascript/">这里</a>。</p>

<h3>3. Promises</h3>

<p>由于JavaScript的异步编程的普遍应用，Promises尤显得重要。众望所归，ES6也把<code>Promises</code>写入草案中了。目前<code>Firefox 30+及Chrome33+</code>实现了<code>Promises</code>，加了这个<a href="https://github.com/jakearchibald/es6-promise">polyfill</a>，我们可以在所有现代浏览器中使用它。</p>

<pre><code class="js">function get(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.open('GET', url);

    xhr.onload = function () {
      var status = xhr.status;

      if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status === 304) {
        resolve(xhr.response);
      } else {
        reject(xhr.statusText);
      }
    };

    xhr.onerror = function () {
      reject('Network error');
    };

    xhr.send(null);
  });
}

function getJSON(url) {
  return get(url).then(JSON.parse);
}

// file1.txt: { "message": "This is the first file." }
// file2.txt: { "message": "This is the second file." }
// file3.txt: 404

let promise = getJSON('file1.txt');

promise
  .then(function (obj) {
    alert(obj.message);
    return getJSON('file2.txt');
  })
  .then(function () {
    alert(obj.message);
    return getJSON('file3.txt');
  })
  .then(function (obj) {
    alert(obj.message);
  })
  .catch(console.log);
</code></pre>

<h3>3. 虚拟对象(Proxies)</h3>

<p><code>Proxies</code>实为虚拟对象，它为对象操纵添加了一道包装，使用它有点Ruby元编程的味道。更多关于<code>Proxies</code>的解释请参阅<a href="http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies">这里</a></p>

<pre><code class="js">// 原型
let handler = {
  get: function (proxy, name) {
    console.log('Getter for ' + name);
  },

  set: function (proxy, name, value) {
    console.log('Setter for ' + name + ' and value of ' + value);
  },

  has: function (name) {
    console.log(name + ' is in the has trap.');
  }
};

var proxy = Proxy.create(handler);

// 实例
let createElement = (function () {
  let specialProps = ['id', 'className'];

  return function (tagName) {
    let element = document.createElement(tagName);

    let p = Proxy.create({
      get: function (proxy, name) {
        if (name === 'node') {
          return element;
        }

        if (name in element) {
          return element[name];
        }

        return element.getAttribute(name);
      },

      set: function (proxy, name, value) {
        if (name === 'node') {
          throw new Error('node cannot be set');
        }

        if (name in element) {
          if (specialProps.indexOf(name) === -1) {
            throw new Error(name + ' cannot be set');
          }

          element[name] = value;
        } else {
          element.setAttribute(name, value);
        }
      }
    });

    return p;
  };
})();

let el = createElement('div'); // proxy

el.id = 'proxyTest';
el.className = 'first-class';
el.classList.add('second-class');
el.foo = 'bar';
el['data-proxy-test'] = true;

console.log(el.node);
console.log(el.id);
console.log(el.className);
console.log(el.foo);
console.log(el['data-proxy-test']);
</code></pre>

<h2>IV、尾声</h2>

<p>更多关于ES6的信息可参阅如下链接：</p>

<ol>
<li><a href="https://github.com/addyosmani/es6-tools">Addy Osmani ES6 Tools</a></li>
<li><a href="http://addyosmani.com/blog/tracking-es6-support/">Tracking ECMAScript 6 Support</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/ECMAScript_6_support_in_Mozilla">ES6 Support in Mozilla</a></li>
<li><a href="http://kangax.github.io/es5-compat-table/es6/">Kangax’s ES6 Support Table</a></li>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts">ES6 Specification Wiki</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闭包陷阱：我中招了！]]></title>
    <link href="http://myunlessor.me/blog/2013/12/09/closure-caveat-it-got-me/"/>
    <updated>2013-12-09T21:37:00+08:00</updated>
    <id>http://myunlessor.me/blog/2013/12/09/closure-caveat-it-got-me</id>
    <content type="html"><![CDATA[<p>一直以来我都以为自己对js的闭包功能掌握的还算可以，最近在工作中却实实在在地被闭包整了一回，特记录于斯，以为警戒！</p>

<!-- more -->


<p>以下代码是从工作中提炼出来的，在这4个case中两次调用<code>howdy()</code>函数时log打印值分别是什么？</p>

<pre><code class="js">// closure caveat

// case 1
;(function (window, $, undefined) {
  var $target;

  function howdy() {
    var x = 'foo';

    if (!$target) {
      $target = $({})
        .on('whatever', function () {
          console.log(x);
        })
        .on('soga', function () {
          x = 'bar';
        });

      $target.triggerHandler('soga');
    }

    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);

// case 2
;(function (window, $, undefined) {
  var $target, x;

  function howdy() {
    x = 'foo';

    if (!$target) {
      $target = $({})
        .on('whatever', function () {
          console.log(x);
        })
        .on('soga', function () {
          x = 'bar';
        });

      $target.triggerHandler('soga');
    }

    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);

// case 3
;(function (window, $, undefined) {
  var $target;

  function howdy() {
    var x = 'foo';

    if (!$target) {
      $target = $({}).on('soga', function () {
        x = 'bar';
      });
    }

    $target
      .off('whatever')
      .on('whatever', function () {
        console.log(x);
      });

    $target.triggerHandler('soga');
    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);

// case 4
;(function (window, $, undefined) {
  var $target, x;

  function howdy() {
    x = 'foo';

    if (!$target) {
      $target = $({}).on('soga', function () {
        x = 'bar';
      });
    }

    $target
      .off('whatever')
      .on('whatever', function () {
        console.log(x);
      });

    $target.triggerHandler('soga');
    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);
</code></pre>

<p>总结：<code>prefer object properties to local variables when recording state!</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[淘宝前端之智勇大闯关第三季攻略]]></title>
    <link href="http://myunlessor.me/blog/2013/08/15/alibaba-ued-quiz3-strategy/"/>
    <updated>2013-08-15T22:42:00+08:00</updated>
    <id>http://myunlessor.me/blog/2013/08/15/alibaba-ued-quiz3-strategy</id>
    <content type="html"><![CDATA[<p>今天在群里看到好多人都在玩这游戏，都玩得挺high，自己也点进链接玩了下，第一次玩这类游戏，觉得挺有意思的，遂记录下自己的玩法。</p>

<p>首先，<a href="http://ued.campus.alibaba.com/quiz3/index.php">游戏链接</a>如下：</p>

<pre><code>http://ued.campus.alibaba.com/quiz3/index.php
</code></pre>

<!-- more -->


<p>该游戏一共有6关。</p>

<h2>第一关 —— 突破，带锁的门</h2>

<p>F12键打开控制台，输入以下代码，密码显现，按不同顺序尝试密码即可通关。</p>

<pre><code class="js">[].forEach.call(Array(11).join('-'), powder.blow.bind(powder));
</code></pre>

<h2>第二关 —— 激光，前进的方向</h2>

<p>该关主要调整id为ma和mb两挡板元素的位置和角度形成反射即可通关，在控制台输入以下代码即可：</p>

<pre><code class="js">(function (doc) {
  var mas = doc.getElementById('ma').style,
      mbs = doc.getElementById('mb').style;

  mas.top = '550px';
  mas.webkitTransform = 'rotate(-82deg)';

  mbs.top = '430px';
  mbs.webkitTransform = 'rotate(172deg)';
}).call(this, document);
</code></pre>

<h2>第三关 —— 坐标，隐藏的线索</h2>

<p>初看这个场景，看到三个定位角块，嗯这是二维码，但是是空白的，审查元素得知它是个canvas元素，需要画图将该二维码补充完整，在控制台输入以下代码完成：</p>

<pre><code class="js">(function (ctx) {
  [].filter.call(document.body.childNodes, function (node) {
    return node.nodeType === 8;
  })[0].data.trim().split(' ').forEach(function (params) {
    ctx.fillRect.apply(ctx, params.split(','));
  });
})(document.getElementById('qr-canvas').getContext('2d'));
</code></pre>

<h2>第四关 —— 图案，疯狂的猜测</h2>

<p>本关类似于看图识字的游戏，在文本框输入图片对应的关键字即可，主要有以下这些：</p>

<pre><code>github
v
css sprite
stackoverflow
underscore
jade
ubuntu
php
less
wordpress
sublime text
w3
grunt
npm
</code></pre>

<h2>第五关 —— 寻找，无尽的房间</h2>

<p>这关看得云里来雾里去，最开始一直更改url中查询字符串room的值，提示你不要人肉。控制台叫你用jquery通关，尝试许久，总结如下方法，在控制台运行后直接通关：</p>

<pre><code class="js">(function ($, loc) {
  var ready = false,
      message = $('#message').text(),
      t = query('t'),
      url = '';

  function query(param) {
    var match = RegExp('[?&amp;]' + param + '=([^&amp;]*)').exec(loc.href.split('#')[0]);
    return match &amp;&amp; decodeURIComponent(match[1].replace(/\+/g, ' '));
  }

  (function yoda(next_room) {
    $.get(loc.href.split('?')[0], {
      t: t,
      room: next_room
    }, function (resp) {
      var msg = $('#message', resp).text(),
          nextRoom = $('#next-room', resp).text();

      console.log(message += msg);

      if (ready) {
        url += msg;
      } else if (msg === '/quiz3/i') {
        ready = !ready;
        url += msg;
      }

      if (nextRoom) {
        yoda(nextRoom);
      } else {
        var nextUrl = loc.protocol + '//' + loc.host + url;
        console.warn('点击进入下一关^_^: ' + nextUrl);
        setTimeout(function () { loc.href = nextUrl; }, 5000);
      }
    });
  })($('#next-room').text());
})(jQuery, location);
</code></pre>

<h2>第六关 —— 消除! 最后的任务</h2>

<p>这关没想到什么好办法，浏览js文件<code>http://ued.campus.alibaba.com/quiz3/assets/js/step5.js</code>看到里面有<code>window.location</code>，于是直接在控制台输入如下代码，顺利通关：</p>

<pre><code class="js">var p = document.getElementById('page').getAttributeNode('data-p').nodeValue;
window.location = Base64.decode(p);
</code></pre>
]]></content>
  </entry>
  
</feed>

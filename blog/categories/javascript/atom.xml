<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章分类: javascript | Silent Reverie]]></title>
  <link href="http://myunlessor.me/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://myunlessor.me/"/>
  <updated>2014-06-17T06:06:05+08:00</updated>
  <id>http://myunlessor.me/</id>
  <author>
    <name><![CDATA[俞乐]]></name>
    <email><![CDATA[myunlessor@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[由Underscore与Lodash的差异引发的思考]]></title>
    <link href="http://myunlessor.me/blog/2014/06/18/ponder-with-underscore-and-lodash/"/>
    <updated>2014-06-18T22:24:00+08:00</updated>
    <id>http://myunlessor.me/blog/2014/06/18/ponder-with-underscore-and-lodash</id>
    <content type="html"><![CDATA[<p>自打接触<a href="http://underscorejs.org/">Underscore</a>以来就对其爱不释手，尔后又了解到<a href="http://lodash.com/">Lodash</a>。这两个类库为我们提供了一系列相当不错的跟函数式编程相关的方法。Underscore以API实现简洁著称。Lodash作为Underscore的后继者，除了对Underscore现有API功能使用上进行扩充外，更是添加了不少令人难忘的API，在性能上也更为出彩，而且还能根据需要构建自己的子集方法。相较而言，我更亲睐于Lodash，而且成了日常项目开发的标配。</p>

<p>目前Lodash的最新版本是v2.4.1，功能上可以说完全是Underscore的超集。只要Underscore添加了啥新功能时，Lodash都会及时覆盖更新，以维护它一如既往超集的地位。然而，当Underscore更新到v1.6.0时，这个版本添加了一个很棒的功能，其为方法<code>_.partial</code>添加了占位符参数的支持（如果没猜错的话，这个特性应该是从<a href="http://osteele.com/sources/javascript/functional/">functional.js</a>中移植过来了）。自然地，希望Lodash也能很快地对<code>_.partial</code>做增强处理。可是，四个月过去了，Lodash似乎处于冬眠状态，一点都不见有动静。于是乎，到目前为止，Lodash的功能不足以完全覆盖Underscore了，于是也就有了这篇文章。</p>

<!-- more -->


<h2>循序渐进</h2>

<p>还是以例子引入话题，假如我要将数组<code>['4', '8', '15', '16', '23', '42']</code>(<a href="http://www.douban.com/group/topic/6251101/">神奇数字</a>)中所有字符串元素变换为数字型。不假思索后，我们会这样写：</p>

<pre><code class="js">//=&gt; [4, 8, 15, 16, 23, 42]
_.map(['4', '8', '15', '16', '23', '42'], function (val) {
  return Number(val);
});
</code></pre>

<p>没错，这没什么问题。稍微观察一下，我们会发现，传递给<code>_.map</code>方法的匿名回调方法仅仅做了件简单的事，将其第一个参数传进<code>Number</code>函数中调用后直接返回。这种做法其实就相当于：你实际要执行的是<code>f</code>函数，而你却通过调用<code>g</code>函数间接执行<code>f</code>函数，而事实上你完全可以直接执行<code>f</code>函数的，如下所示：</p>

<pre><code class="js">var f = function (val) { return val; };
var g = function (val) { return f(val); };

//=&gt; true
f('stupid') === g('stupid');
</code></pre>

<p>因此，上述数组变换实际可以简化为：</p>

<pre><code class="js">//=&gt; [4, 8, 15, 16, 23, 42]
_.map(['4', '8', '15', '16', '23', '42'], Number);
</code></pre>

<p>嗯，确实是这么回事^-^。</p>

<p>再比如，我想将数组<code>['1NO', '2FOOL', '3ME']</code>中所有字符串元素解析为数字型。我们知道将字符串解析为数字型可以通过<code>parseInt</code>直接得到，像这样：</p>

<pre><code class="js">var first = parseInt('1NO');     //=&gt; 1
var middle = parseInt('2FOOL');  //=&gt; 2
var last = parseInt('3ME');      //=&gt; 3
</code></pre>

<p>It works! 于是以迅雷不及掩耳的速度得出结果：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map(['1NO', '2FOOL', '3ME'], function (val) {
  return parseInt(val);
});
</code></pre>

<p>Perfect！细看一下，咿，这不是和之前那个例子一样的嘛，这次学聪明了，窃喜之下后马上将结果改为如下，也没忘夸奖下自己随机应变的能力：</p>

<pre><code class="js">//=&gt; [1, NaN, NaN]
_.map(['1NO', '2FOOL', '3ME'], parseInt);
</code></pre>

<p>等等，我勒个去，结果不符合预期了，这是怎么回事？！</p>

<p>脑袋稍微转下，原来是这么回事，当你把<code>parseInt</code>直接作为<code>_.map</code>方法的回调时，<code>parseInt</code>执行的时候实际是传入了三个参数(元素值，元素索引，数组本身)。
所以上述代码实际等价于：</p>

<pre><code class="js">var ary = ['1NO', '2FOOL', '3ME'];

//=&gt; [1, NaN, NaN]
_.map(ary, function (val, idx, ary) {
  return parseInt(val, idx, ary);
});

var first = parseInt('1NO', 0, ary);     //=&gt; 1
var middle = parseInt('2FOOL', 1, ary);  //=&gt; NaN
var last = parseInt('3ME', 2, ary);      //=&gt; NaN
</code></pre>

<p><code>parseInt</code>调用时可接收可选的第二个参数，元素索引值作为第二个参数无形中传入到<code>parseInt</code>，呜呼哀哉！第一个例子为什么没问题？因为Number只接收一个参数，而把其后的所有参数都忽略，所以安然无恙。这么看来<code>Explicit is better than implicit(显优于隐)</code>的确是真理啊！</p>

<p>在此，我不想弹劾<code>parseInt</code>直接作为<code>_.map</code>回调使用的情况，我只想吐嘈下<code>parseInt</code>不显式指定第二个参数调用的隐患。MDN上关于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt API</a>的定义是强调指明要传入<code>radix(基数)</code>值作为解析数字的依据的。</p>

<p>除此以外，我想强调的是<code>Number</code>和<code>parseInt</code>是否有<code>共同特征(pattern recognition)</code>值得我们去挖掘的呢？答案是有的。<code>_.map</code>遍历数组元素时，其都是将数组元素传入到<code>Number</code>或<code>parseInt</code>作为其第一个参数进行执行的。而这是函数式编程很重要的一个特点，对函数进行<code>柯里化(curry)</code>或<code>偏应用(partial)</code>处理时，传给函数的第一个参数往往是数据流，<code>数据流(data flow)</code>也是函数式编程不同于<code>控制流(control flow)</code>的非函数式编程的一个显著区别。</p>

<p>回到之前的问题，既然<code>parseInt</code>不能直接作为<code>_.map</code>回调处理，而我又不想使用匿名函数间接调用<code>parseInt</code>的刻板方法，那么还有其他办法吗？答案是有的。</p>

<p>试想，我们遇到的问题是<code>parseInt</code>作为<code>_.map</code>回调执行时，无形中其第二个参数被污染了。反过来想，我们要找到一个办法使得其第二个参数免受污染。所幸的是，Underscore v1.6.0版本中提供的<code>_.partial</code>正好能满足这一需求。</p>

<p>我的想法是，利用<code>_.partial</code>对<code>parseInt</code>进行偏应用处理，返回得到的新函数再作为回调传入<code>_.map</code>中，如下所示：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map(['1NO', '2FOOL', '3ME'], _.partial(parseInt, _, 10));
</code></pre>

<p>在这个例子中，我们为<code>parseInt</code>预填充了两个参数：第一个参数传入<code>_</code>代表参数占位符，它是动态值；第二个传入基数值10，它是不变的，这样我们就将其第第二个参数“锁定”了。当<code>_.map</code>回调函数被执行时，它还是依次接收三个参数回来，只不过这次接收的第一个参数（数组元素作为数据填补）代替了参数占位符的位置，第二、三个参数被依次追加到<code>parseInt</code>末尾而被忽略，于是我们的代码正常工作了。</p>

<p>然而，这行代码Underscore v1.6.0+版本中才有效，对于Lodash或更低版本的Underscore，我们该怎么办呢？这时函数柯里化的威力就体现出来了。因为<code>parseInt</code>接收两个参数，于是我构建如下的二级柯里化函数：</p>

<pre><code class="js">function curry2(fun) {
  return function (second) {
    return function (first) {
      return fun(first, second);
    };
  };
}
</code></pre>

<p>函数<code>curry2</code>调用时接收一个希望被柯里化的函数作为参数传入，方法体中返回一个匿名函数，接收单一参数，而在匿名函数中又再次返回一个匿名函数，同样接收单一参数，直到柯里化函数执行两次时，被柯里化的函数得以执行，两级柯里化参数逆序传入而返回。</p>

<p>应用到这个例子，即：我们对<code>parseInt</code>进行柯里化处理，执行一次传入参数10，也是预填充第二个参数，结果返回新的函数等待<code>_.map</code>被执行时将第一个参数传递进行而返回结果值，代码如下：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map(['1NO', '2FOOL', '3ME'], curry2(parseInt)(10));
</code></pre>

<p>在这个妥协的解决方法里，我们借助了自己构建的柯里化函数作为辅助。这不禁让我这么想：难道在这泱泱几十号工具方法中，在这个问题上一无是处，无一能为我所用，反倒要依赖外援？思考片刻后，依照<code>curry2</code>的思路，想到Lodash不是提供有<code>_.partialRight</code>方法嘛！从左往右填充参数不行，那就从右往左介入。就像<code>curry2</code>那样给<code>parseInt</code>预填充第二个参数，然后等待<code>_.map</code>填充第一个参数后执行，于是写了如下代码：</p>

<pre><code class="js">//=&gt; [1, NaN, NaN]
_.map(['1NO', '2FOOL', '3ME'], _.partialRight(parseInt, 10));
</code></pre>

<p>结果不尽如人意，和<code>parseInt</code>直接作为<code>_.map</code>回调函数传入时结果没什么两样，执行时<code>parseInt</code>仍是被<code>_.map</code>传回来的多余参数污染了，基数10成为了<code>parseInt</code>的末尾参数而直接忽略了。多余？这给我提了个醒，如果我能将<code>_.map</code>传回来的多余的后两参数过滤掉，那么<code>parseInt</code>被执行时作为基数10的末尾参数是不是就是作为其第二个参数传入而正常了。Great！现在的问题变成了如何将<code>_.map</code>传回来的多余的后两参数过滤掉？思考良久后我辗转想到了<code>_.identity</code>。<code>_.identity</code>应该算Lodash中倒数第二简单的方法了吧，最简单的是<code>_.noop</code>，它们各自定义如下所示：</p>

<pre><code class="js">_.noop = function () {};
_.identity = function (val) { return val; };
</code></pre>

<p>简单的东西并非一无是处。麻雀虽小，五脏俱全。有时候往往是简单的东西才是我们需要的东西。咋一看，<code>_.identity</code>不就是你给它什么输入，它就给你返回什么嘛。可是当你换个角度想，你却发现了别样的东西，直接上代码：</p>

<pre><code class="js">_.identity('I');                  //=&gt; 'I'
_.identity('I', 'FOOL');          //=&gt; 'I'
_.identity('I', 'FOOL', 'YOU');   //=&gt; 'I'
</code></pre>

<p>发现了什么？所以，更准确地说，无论你给<code>_.identity</code>传入多少个参数，结果都是返回给你传入的第一个参数。这样一想，我传三个参数给它，结果它只把第一个参数返回了，剩余那两个参数呢？消失在茫茫人海之中，不见了。Good Job！</p>

<p>好了，现在解决了参数过滤的问题，我该怎么把过滤后存活下来的第一个参数传给<code>partial right</code>后的<code>parseInt</code>函数使用呢。我们需要管道进行衔接，一个函数的输出作为接下来另一个函数的输入，<code>_.compose</code>不正是专门做这事的嘛，Yeah！</p>

<p>假设<code>f</code>和<code>g</code>是两函数，<code>f</code>函数调用后的输出作为<code>g</code>函数的输入，其中<code>x</code>是<code>f</code>的输入值，则以下等式是成立的：</p>

<pre><code class="js">_.isEqual( g(f(x)), _.compose(g, f)(x) );
</code></pre>

<p>有了以上的分析后，我们通过<code>_.compose</code>作为纽带将<code>partial right</code>后的<code>parseInt</code>和<code>_.identity</code>衔接起来，最终得到答案：</p>

<pre><code class="js">//=&gt; [1, 2, 3]
_.map( ['1NO', '2FOOL', '3ME'], _.compose( _.partialRight(parseInt, 10), _.identity ) );
</code></pre>

<p>看到以上这行代码，你在脑海中涌动的应该就是数据在各个函数间依次流动着而最终得到结果，即函数式编程的<code>数据流(data flow)</code>思想。我并不是倡导在实际工作中要写这种代码，更多的是体会函数式编程的思维，那种自成一体的曼妙。函数式编程的思想表现的不是<code>MARVEL</code>旗下的那些个个人英雄主义气概，而是各个功能单一的函数组合在一起才能体现的威力。</p>

<h2>思维发散</h2>

<p>另一个例子：将数组<code>['left  ', ' center ', '  right']</code>中各个字符串元素两边的空白符去除，长驱直入：</p>

<pre><code class="js">//=&gt; ['left', 'center', 'right']
_.map(['left  ', ' center ', '  right'], function (s) {
  return s.trim();
});
</code></pre>

<p>仔细看这段代码，你会看到另一种模式，匿名函数里返回的是第一个参数调用某个方法的结果。函数式编程的核心是函数，而不是方法。我们要将方法调用转化为函数调用，才更能体现函数式风格。Underscore和Lodash都提供了<code>_.result</code>方法。通过这个方法我们可以将方法调用转化为函数调用，也即：</p>

<pre><code class="js">var str = ' center ';

//=&gt; true
str.trim() === _.result(str, 'trim');
</code></pre>

<p><code>_.result</code>调用像不像此前的<code>parseInt</code>？这样，我们之前的方法再次奏效：</p>

<pre><code class="js">var ary = ['left  ', ' center ', '  right'];

// Underscore v1.6.0
_.map(ary, _.partial( _.result, _, 'trim' ));

// Lodash v2.4.1
_.map(ary, _.compose( _.partialRight( _.result, 'trim' ), _.identity ));

// Underscore &amp; Lodash
_.map(ary, curry2( _.result )( 'trim' ));
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[howdy]]></title>
    <link href="http://myunlessor.me/blog/2014/06/17/one-way-to-implement-pagination-folding-logic/"/>
    <updated>2014-06-17T10:28:00+08:00</updated>
    <id>http://myunlessor.me/blog/2014/06/17/one-way-to-implement-pagination-folding-logic</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅尝ECMAScript 6]]></title>
    <link href="http://myunlessor.me/blog/2014/03/01/venture-into-es6/"/>
    <updated>2014-03-01T10:43:00+08:00</updated>
    <id>http://myunlessor.me/blog/2014/03/01/venture-into-es6</id>
    <content type="html"><![CDATA[<p>现在ECMAScript 6草案制定在不断地推进，浏览器们也在跟进实现，了解ES6的提供的诸多特性是势在必行的事了。</p>

<p>有关浏览器们对ECMAScript 6草案的实现情况可参阅<a href="http://kangax.github.io/es5-compat-table/es6/">这里</a>。</p>

<p>有关ES6的语言特性可参阅<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures">这里</a>。</p>

<p>目前对ES6实现较为充分的环境有<a href="https://github.com/google/traceur-compiler">Google Traceur Compiler</a>及<a href="http://nightly.mozilla.org/">Firefox Nightly</a>。</p>

<p>有关<code>traceur compiler</code>的环境配置如下：</p>

<p>```html</p>

<script src="https://traceur-compiler.googlecode.com/git/bin/traceur.js"></script>


<script src="https://traceur-compiler.googlecode.com/git/src/bootstrap.js"></script>


<script>
traceur.options.experimental = true;
</script>


<script>
  // blablabla...
</script>


<p>```</p>

<!-- more -->


<h2>I、新的语法</h2>

<h3>1. 块作用域(Block Scope)</h3>

<p><code>var</code>关键字声明的变量具有函数作用域或全局作用域，而通过<code>let</code>关键字将变量声明为块作用域，对比如下：</p>

<pre><code class="js">// 在块(curly)作用域中声明并初始化变量
{ var foo = 'foo'; }
{ let bar = 'bar'; }

console.log(foo); // -&gt; 'foo'
console.log(bar); // ReferenceError: bar is not defined
</code></pre>

<h3>2. 常量(Constants)</h3>

<p>许多语言都有常量的概念(值不能改变的变量)。ES6草案将常量引入到了JavaScript中。</p>

<p>使用<code>const</code>关键字将变量声明为常量，规范要求<code>const</code>声明的常量具块作用域，某些浏览器目前将其实现为函数作用域或全局作用域。声明变量为常量时如果不赋值，某些浏览器会将该变量赋<code>undefined</code>值，而某些浏览器则直接报错。为常量重新赋值，某些浏览器会忽略新赋值，某些浏览器会报错。将引用类型（如数组或对象）声明为常量，并不影响引用类型的扩充行为：</p>

<pre><code class="js">const noexist;             // Const must be initialized (IE)
const foo = 'foo';
foo = 'hoo';               // Assignment to const (IE)
console.log(foo);          // -&gt; 'foo'

// 常量引用类型并不影响对其自身的扩充(`augument`)
const bar = [];
bar.push('spam', 'eggs');
console.log(bar.length);   // -&gt; 2

// 同上
const baz = {};
baz.spam = 'eggs';
console.log(baz.spam);     // -&gt; 'eggs'
</code></pre>

<h3>3. 默认参数(Default Parameters)</h3>

<p>函数声明时可以为参数赋予默认值，这样函数调用时如果参数缺省(<code>undefined</code>)，则该参数会被赋予默认值，使用默认参数在一定程序上使函数声明更为直观，并且简化我们的代码。</p>

<pre><code class="js">// 传统写法
function fill(container, liquid) {
  if (typeof liquid === 'undefined') {
    liquid = 'coffee';
  }
  // blablabla...
}

// 新式写法
function fill(container, liquid = 'coffee') {
  // blablabla...
}
</code></pre>

<h3>4. Rest和Spread操作符</h3>

<p>很多时候我们处理函数的时候需要用到数组参数，ES6提供的<code>Rest</code>和<code>Spread</code>操作符可以让我们更方便地处理数组参数。</p>

<p><code>rest</code>是将多值折叠为单值集合的过程，和<code>rest</code>相反，<code>spread</code>是将单值集合展开为多值的过程。很多语言都有对它的支持，语法略有差异，Python、Ruby和CoffeeScript将这种语法统称为<code>splats</code>，Python和Ruby用形如<code>*var</code>的语法来表达。CoffeeScript用形如<code>var...</code>的语法来表达，而ES6则用形如<code>...var</code>的语法来表达。</p>

<pre><code class="js">// 1. rest
function unary(...first) {
  console.log(first);
}

function binary(first, ...rest) {
  console.log([first, rest]);
}

unary('foo');                 // -&gt; ['foo']
unary('foo', 'bar');          // -&gt; ['foo', 'bar']

binary('foo');                // -&gt; ['foo', []]
binary('foo', 'bar', 'baz');  // -&gt; ['foo', ['bar', 'baz']]

// rest实现
;(function (window, undefined) {
  var _slice = Array.prototype.slice;

  function variadic(fn) {
    var numParams    = fn.length, // 形参个数
        numNamedArgs = numParams - 1;


    return numParams &lt; 1 ? fn : function () {
      var
        numArgs             = arguments.length, // 实参个数
        namedArgs           = _slice.call(arguments, 0, numNamedArgs),
        numMissingNamedArgs = Math.max(0, numNamedArgs - numArgs),
        argPadding          = Array(numMissingNamedArgs),
        variadicArgs        = _slice.call(arguments, numNamedArgs);

      return fn.apply(this, namedArgs
                              .concat(argPadding)
                              .concat([variadicArgs]));
    };
  }

  window.variadic = variadic;
}).call(this, this);

// -&gt; ['why', 'hello', 'there']
variadic(unary)('why', 'hello', 'there');

// -&gt; ['why', ['hello', 'there']]
variadic(binary)('why', 'hello', 'there');

// ----------------------------------------------------

// 2. spread
var numbers = [1, 2, 3, 4, 5];

// 传统写法
var max = Math.max.apply(Math, number);

var filled = numbers.slice(0);
[].push.apply(filled, [6, 7, 8, 9, 10]);

// 新式写法
var max = Math.max(...number);
var filled = [...numbers, 6, 7, 8, 9, 10]
</code></pre>

<h3>5. 解构赋值(Destructuring Assignment)</h3>

<p>如果你想从数组中拿取多个元素并赋予其他变量，或是从函数中返回多值，那么ES6提供的<code>解构赋值(Destructuring Assignment)</code>特性正是我们所需要的。</p>

<pre><code class="js">// 1. 数组解构赋值
let a = 1, b = 2;
[b, a] = [a, b];   // swap two variabls

console.log(a, b); // -&gt; 2 1

function dest() {
  return ['why', 'hello', 'there'];
}

let [foo, bar, baz] = dest();

// -&gt; 'why' 'hello' 'there'
console.log(foo, bar, baz);

// 忽略不需要的值
let [a, , c] = dest();

// -&gt; 'why' 'there'
console.log(a, c);

// 2. 对象解构赋值
let janeDoe = {
  first: 'jane',
  last: 'doe',
  gender: 'female',
  hobbies: ['music', 'sports']
};

let { first: firstName, last: lastName } = janeDoe;

// -&gt; 'jane' 'doe'
console.log(firstName, lastName);

let { first, last } = janeDoe;

// -&gt; 'jane' 'doe'
console.log(first, last);

function whatever({ first: f, last: l }) {
  console.log(f, l);
}

// -&gt; 'jane' 'doe'
whatever(janeDoe);

function another({ gender, hobbies: [hob1, hob2] }) {
  console.log(gender, hob1, hob2);
}

// -&gt; 'female' 'music' 'sports'
another(janeDoe);
</code></pre>

<h3>6. for…of 循环语句</h3>

<p>ES6新引入了<code>for…of</code>循环语句，以往我们使用的<code>for..in</code>循环语句用于迭代对象的<code>属性(properties)</code>，而新式的for…of循环语句则用于迭代对象的<code>值(values)</code>。</p>

<pre><code class="js">var numbers = [1, 2, 3, 4, 5];

// 传统写法
numbers.forEach(function (number) {
  console.log(number);
});

// 新式写法
for (let number of numbers) {
  console.log(number);
}
</code></pre>

<h3>7. 迭代器(Iterators)</h3>

<p><code>for..of</code>循环只对迭代对象有效，这意味着要使一个对象可迭代，对象自身需要迭代器。具体可移步参阅<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures#wiki-iterators-and-for-of-loops">这里</a></p>

<h3>8. 生成器(Generators)</h3>

<p>生成器可以创建迭代器，并且可以用它来创建自定义迭代对象。生成器异常强大，网上你可以找到它联合<code>Promises</code>一起使用的情形，它为ajax异步调用开启一个新的世界，一个没有<code>callbacks</code>，没有<code>then</code>的世界，它的强大会超乎你的想象。</p>

<pre><code class="js">// 基本用法
function* numberGen() {
  let limit = 3, i = 0;

  do {
    yield i++;
  } while (i &lt; limit);
}

let iter = numberGen();

// -&gt; { value: 0, done: false }
iter.next();

// -&gt; { value: 1, done: false }
iter.next();

// -&gt; { value: 2, done: false }
iter.next();

// -&gt; { value: undefined, done: true }
iter.next();

// 过滤偶数
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

function* even(numbers) {
  for (let n of numbers) {
    if (n % 2 === 0) {
      yield n;
    }
  }
}

for (let n of even(numbers)) {
  console.log(n);
}

// 延伸用法1
let janeDoe = {
  first: 'jane',
  last: 'doe'
};

function* iterObj(obj) {
  for (let prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      yield [prop, obj[prop]];
    }
  }
}

// -&gt; "first: jane"
// -&gt; "last: doe"
for (let [key, value] of iterObj(janeDoe)) {
  console.log([key, value].join(': '));
}

// 延伸用法2
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

Person.prototype.greeting = function (name) {
  return 'Hello, ' + name;
};

// Person.prototype[Symbol.iterator]
Person.prototype['@@iterator'] = function* () {
  for (let prop in this) {
    if (this.hasOwnProperty(prop)) {
      yield [prop, this[prop]];
    }
  }
};

let johndoe = new Person('john', 'doe');

// -&gt; "first: john"
// -&gt; "last: doe"
for (let [key, value] of johndoe) {
  console.log([key, value].join(': '));
}
</code></pre>

<h3>9. Comprehensions</h3>

<p>Python最早引入了<code>List Comprehensions(列表推导)</code>的概念，这一特性深受程序员的喜爱，这一特性继而引申出<code>Dict Comprehensions</code>及<code>Generator Comprehensions</code>。CoffeeScript设计时也参考了Python，它也有<code>Comprehensions</code>的概念。而作为日渐流行的JavaScript，这么好的东西怎么能错过呢？自然而然地它也成为了JavaScript的标配。
我们在操作数组的时候经常会使用<code>Array.prototype.map</code>和<code>Array.prototype.filter</code>方法，ES6为我们提供的<code>Comprehensions</code>简直可以称为这两个方法提供<code>语法糖(syntax sugar)</code>，其语法表达直白、简明、形象。</p>

<pre><code class="js">let fruits = ['apple', 'orange', 'banana'];

// 传统应用
let ripeFruits = fruits.map(function (item) {
  return 'ripe ' + item;
});

let fruitsWithN = fruits.filter(function (item) {
  return item.indexOf('n') &gt; -1;
});

console.log(ripeFruits);
console.log(fruitsWithN);

// 新式玩法
// 1. 数组推导(Array Comprehension)
let ripeFruits2 = ['ripe ' + item for (item of fruits)];
let fruitsWithN2 = [item for (item of fruits) if (item.indexOf('n') &gt; -1)];
let ripeFruitsWithN = ['ripe ' + item for (item of fruits) if (item.indexOf('n') &gt; -1)];

console.log(ripeFruits2);
console.log(fruitsWithN2);
console.log(ripeFruitsWithN);

// 2. 生成器推导(Generator Comprehension)
let iter = ('ripe ' + item for (item of fruits) if (item.indexOf('n') &gt; -1));
console.log(iter.next()); // -&gt; "ripe orange"
console.log(iter.next()); // -&gt; "ripe banana"
</code></pre>

<h3>10. 箭头函数(Arrow Functions)</h3>

<p>有关ES6箭头函数的介绍移步<a href="http://www.nczonline.net/blog/2013/09/10/understanding-ecmascript-6-arrow-functions/">这里</a>参阅。</p>

<h2>II、新的代码组织方式</h2>

<h3>1. 类(Classes)</h3>

<p>移步<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures#wiki-classes">这里</a>以及<a href="http://www.nczonline.net/blog/2012/10/16/does-javascript-need-classes/">这里</a>进行参阅。</p>

<h3>2. 模块(Modules)</h3>

<p>移步<a href="https://github.com/google/traceur-compiler/wiki/LanguageFeatures#wiki-modules">这里</a>进行参阅。</p>

<h2>III、新的标准类库</h2>

<h3>1. 集合(Set)</h3>

<p>Python的作者是个数学家，所以这门语言早期就有了对<code>Set</code>的支持。现在，ES6也将<code>Set</code>纳为标配了。有了集合，数组去除已然不费吹灰之力了。
更详细的介绍请移步<a href="http://www.nczonline.net/blog/2012/09/25/ecmascript-6-collections-part-1-sets/">这里</a>。</p>

<pre><code class="js">// 创建集合实例
let items = new Set([1, 2, 2, 3, 4, 3, 5, '2']);

// 判断指定元素是否在集合中
console.log(items.has('2'));

// 遍历集合元素
for (let item of items) {
  console.log(item);
}

// 添加元素到集合中
items.add(6);

// 从集合中移除元素
items.delete(1);

// 获取集合里元素个数
console.log(items.size);

// 遍历集合元素
for (let item of items) {
  console.log(item);
}

// 移除集合里所有元素
items.clear();
</code></pre>

<h3>2. 映射(Map)</h3>

<p>以往我们都是使用字面对象构建键值对映射，ES6提供的<code>Map</code>结构提供了友好直白的API让我们可以更好地操纵键值对，就像<code>localStorge</code>一样，它使我们更好地在客户端保存数据。
更详细的介绍请移步<a href="http://www.nczonline.net/blog/2012/10/09/ecmascript-6-collections-part-2-maps/">这里</a>。</p>

<pre><code class="js">// 创建映射实例
let stuff = new Map();

// 设置键值对
stuff.set('foo', 'bar')
// 你没看错，对象也可以作为Map的key
stuff.set(document, document.createElement('div'));

// 判断是否设置了指定键
console.log(stuff.has('foo'));

// 获取键值对个数
console.log(stuff.size);

// 获取指定键的值
console.log(stuff.get('foo'));

// 删除指定的键
stuff.delete('foo');

// 清除所有键
stuff.clear();

// 遍历键值对
for (let item of stuff) {
  // key = item[0];
  // value = item[1];
  // do something
}

// 同上
for (let item of stuff.items()) {
  // do something
}

// 同上(解构赋值)
for (let [key, value] of stuff) {
  // do something
}

// 遍历所有键
for (let key of stuff.keys()) {
  // do something
}

// 遍历所有值
for (let value of stuff.values()) {
  // do something
}
</code></pre>

<h3>2. 弱映射(WeakMap)</h3>

<p><code>WeakMap</code>和<code>Map</code>类似，但<code>WeakMap</code>的键只能为对象，而不能为原始类型。
有关<code>WeakMap</code>的详细的介绍请移步<a href="http://www.nczonline.net/blog/2012/11/06/ecmascript-6-collections-part-3-weakmaps/">这里</a>以及<a href="http://www.nczonline.net/blog/2014/01/21/private-instance-members-with-weakmaps-in-javascript/">这里</a>。</p>

<h3>3. Promises</h3>

<p>由于JavaScript的异步编程的普遍应用，Promises尤显得重要。众望所归，ES6也把<code>Promises</code>写入草案中了。目前<code>Firefox 30+及Chrome33+</code>实现了<code>Promises</code>，加了这个<a href="https://github.com/jakearchibald/es6-promise">polyfill</a>，我们可以在所有现代浏览器中使用它。</p>

<pre><code class="js">function get(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.open('GET', url);

    xhr.onload = function () {
      var status = xhr.status;

      if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status === 304) {
        resolve(xhr.response);
      } else {
        reject(xhr.statusText);
      }
    };

    xhr.onerror = function () {
      reject('Network error');
    };

    xhr.send(null);
  });
}

function getJSON(url) {
  return get(url).then(JSON.parse);
}

// file1.txt: { "message": "This is the first file." }
// file2.txt: { "message": "This is the second file." }
// file3.txt: 404

let promise = getJSON('file1.txt');

promise
  .then(function (obj) {
    alert(obj.message);
    return getJSON('file2.txt');
  })
  .then(function () {
    alert(obj.message);
    return getJSON('file3.txt');
  })
  .then(function (obj) {
    alert(obj.message);
  })
  .catch(console.log);
</code></pre>

<h3>3. 虚拟对象(Proxies)</h3>

<p><code>Proxies</code>实为虚拟对象，它为对象操纵添加了一道包装，使用它有点Ruby元编程的味道。更多关于<code>Proxies</code>的解释请参阅<a href="http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies">这里</a></p>

<pre><code class="js">// 原型
let handler = {
  get: function (proxy, name) {
    console.log('Getter for ' + name);
  },

  set: function (proxy, name, value) {
    console.log('Setter for ' + name + ' and value of ' + value);
  },

  has: function (name) {
    console.log(name + ' is in the has trap.');
  }
};

var proxy = Proxy.create(handler);

// 实例
let createElement = (function () {
  let specialProps = ['id', 'className'];

  return function (tagName) {
    let element = document.createElement(tagName);

    let p = Proxy.create({
      get: function (proxy, name) {
        if (name === 'node') {
          return element;
        }

        if (name in element) {
          return element[name];
        }

        return element.getAttribute(name);
      },

      set: function (proxy, name, value) {
        if (name === 'node') {
          throw new Error('node cannot be set');
        }

        if (name in element) {
          if (specialProps.indexOf(name) === -1) {
            throw new Error(name + ' cannot be set');
          }

          element[name] = value;
        } else {
          element.setAttribute(name, value);
        }
      }
    });

    return p;
  };
})();

let el = createElement('div'); // proxy

el.id = 'proxyTest';
el.className = 'first-class';
el.classList.add('second-class');
el.foo = 'bar';
el['data-proxy-test'] = true;

console.log(el.node);
console.log(el.id);
console.log(el.className);
console.log(el.foo);
console.log(el['data-proxy-test']);
</code></pre>

<h2>IV、尾声</h2>

<p>更多关于ES6的信息可参阅如下链接：</p>

<ol>
<li><a href="https://github.com/addyosmani/es6-tools">Addy Osmani ES6 Tools</a></li>
<li><a href="http://addyosmani.com/blog/tracking-es6-support/">Tracking ECMAScript 6 Support</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/ECMAScript_6_support_in_Mozilla">ES6 Support in Mozilla</a></li>
<li><a href="http://kangax.github.io/es5-compat-table/es6/">Kangax’s ES6 Support Table</a></li>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts">ES6 Specification Wiki</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闭包陷阱：我中招了！]]></title>
    <link href="http://myunlessor.me/blog/2013/12/09/closure-caveat-it-got-me/"/>
    <updated>2013-12-09T21:37:00+08:00</updated>
    <id>http://myunlessor.me/blog/2013/12/09/closure-caveat-it-got-me</id>
    <content type="html"><![CDATA[<p>一直以来我都以为自己对js的闭包功能掌握的还算可以，最近在工作中却实实在在地被闭包整了一回，特记录于斯，以为警戒！</p>

<!-- more -->


<p>以下代码是从工作中提炼出来的，在这4个case中两次调用<code>howdy()</code>函数时log打印值分别是什么？</p>

<pre><code class="js">// closure caveat

// case 1
;(function (window, $, undefined) {
  var $target;

  function howdy() {
    var x = 'foo';

    if (!$target) {
      $target = $({})
        .on('whatever', function () {
          console.log(x);
        })
        .on('soga', function () {
          x = 'bar';
        });

      $target.triggerHandler('soga');
    }

    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);

// case 2
;(function (window, $, undefined) {
  var $target, x;

  function howdy() {
    x = 'foo';

    if (!$target) {
      $target = $({})
        .on('whatever', function () {
          console.log(x);
        })
        .on('soga', function () {
          x = 'bar';
        });

      $target.triggerHandler('soga');
    }

    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);

// case 3
;(function (window, $, undefined) {
  var $target;

  function howdy() {
    var x = 'foo';

    if (!$target) {
      $target = $({}).on('soga', function () {
        x = 'bar';
      });
    }

    $target
      .off('whatever')
      .on('whatever', function () {
        console.log(x);
      });

    $target.triggerHandler('soga');
    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);

// case 4
;(function (window, $, undefined) {
  var $target, x;

  function howdy() {
    x = 'foo';

    if (!$target) {
      $target = $({}).on('soga', function () {
        x = 'bar';
      });
    }

    $target
      .off('whatever')
      .on('whatever', function () {
        console.log(x);
      });

    $target.triggerHandler('soga');
    $target.triggerHandler('whatever');
  }

  howdy();
  howdy();
})(this, jQuery);
</code></pre>

<p>总结：<code>prefer object properties to local variables when recording state!</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[淘宝前端之智勇大闯关第三季攻略]]></title>
    <link href="http://myunlessor.me/blog/2013/08/15/alibaba-ued-quiz3-strategy/"/>
    <updated>2013-08-15T22:42:00+08:00</updated>
    <id>http://myunlessor.me/blog/2013/08/15/alibaba-ued-quiz3-strategy</id>
    <content type="html"><![CDATA[<p>今天在群里看到好多人都在玩这游戏，都玩得挺high，自己也点进链接玩了下，第一次玩这类游戏，觉得挺有意思的，遂记录下自己的玩法。</p>

<p>首先，<a href="http://ued.campus.alibaba.com/quiz3/index.php">游戏链接</a>如下：</p>

<pre><code>http://ued.campus.alibaba.com/quiz3/index.php
</code></pre>

<!-- more -->


<p>该游戏一共有6关。</p>

<h2>第一关 —— 突破，带锁的门</h2>

<p>F12键打开控制台，输入以下代码，密码显现，按不同顺序尝试密码即可通关。</p>

<pre><code class="js">[].forEach.call(Array(11).join('-'), powder.blow.bind(powder));
</code></pre>

<h2>第二关 —— 激光，前进的方向</h2>

<p>该关主要调整id为ma和mb两挡板元素的位置和角度形成反射即可通关，在控制台输入以下代码即可：</p>

<pre><code class="js">(function (doc) {
  var mas = doc.getElementById('ma').style,
      mbs = doc.getElementById('mb').style;

  mas.top = '550px';
  mas.webkitTransform = 'rotate(-82deg)';

  mbs.top = '430px';
  mbs.webkitTransform = 'rotate(172deg)';
}).call(this, document);
</code></pre>

<h2>第三关 —— 坐标，隐藏的线索</h2>

<p>初看这个场景，看到三个定位角块，嗯这是二维码，但是是空白的，审查元素得知它是个canvas元素，需要画图将该二维码补充完整，在控制台输入以下代码完成：</p>

<pre><code class="js">(function (ctx) {
  [].filter.call(document.body.childNodes, function (node) {
    return node.nodeType === 8;
  })[0].data.trim().split(' ').forEach(function (params) {
    ctx.fillRect.apply(ctx, params.split(','));
  });
})(document.getElementById('qr-canvas').getContext('2d'));
</code></pre>

<h2>第四关 —— 图案，疯狂的猜测</h2>

<p>本关类似于看图识字的游戏，在文本框输入图片对应的关键字即可，主要有以下这些：</p>

<pre><code>github
v
css sprite
stackoverflow
underscore
jade
ubuntu
php
less
wordpress
sublime text
w3
grunt
npm
</code></pre>

<h2>第五关 —— 寻找，无尽的房间</h2>

<p>这关看得云里来雾里去，最开始一直更改url中查询字符串room的值，提示你不要人肉。控制台叫你用jquery通关，尝试许久，总结如下方法，在控制台运行后直接通关：</p>

<pre><code class="js">(function ($, loc) {
  var ready = false,
      message = $('#message').text(),
      t = query('t'),
      url = '';

  function query(param) {
    var match = RegExp('[?&amp;]' + param + '=([^&amp;]*)').exec(loc.href.split('#')[0]);
    return match &amp;&amp; decodeURIComponent(match[1].replace(/\+/g, ' '));
  }

  (function yoda(next_room) {
    $.get(loc.href.split('?')[0], {
      t: t,
      room: next_room
    }, function (resp) {
      var msg = $('#message', resp).text(),
          nextRoom = $('#next-room', resp).text();

      console.log(message += msg);

      if (ready) {
        url += msg;
      } else if (msg === '/quiz3/i') {
        ready = !ready;
        url += msg;
      }

      if (nextRoom) {
        yoda(nextRoom);
      } else {
        var nextUrl = loc.protocol + '//' + loc.host + url;
        console.warn('点击进入下一关^_^: ' + nextUrl);
        setTimeout(function () { loc.href = nextUrl; }, 5000);
      }
    });
  })($('#next-room').text());
})(jQuery, location);
</code></pre>

<h2>第六关 —— 消除! 最后的任务</h2>

<p>这关没想到什么好办法，浏览js文件<code>http://ued.campus.alibaba.com/quiz3/assets/js/step5.js</code>看到里面有<code>window.location</code>，于是直接在控制台输入如下代码，顺利通关：</p>

<pre><code class="js">var p = document.getElementById('page').getAttributeNode('data-p').nodeValue;
window.location = Base64.decode(p);
</code></pre>
]]></content>
  </entry>
  
</feed>
